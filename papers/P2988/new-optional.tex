
  \rSec2[optional.optional]{Class template \tcode{optional}}

  \rSec3[optional.optional.general]{General}

  \indexlibraryglobal{optional}%
  \indexlibrarymember{value_type}{optional}%
  \begin{removedblock}
    \begin{codeblock}
template<class U> constexpr T value_or(U&&) const &;
template<class U> constexpr T value_or(U&&) &&;
\end{codeblock}
\end{removedblock}

\begin{addedblock}
  \begin{codeblock}
template <class U = remove_cvref_t<T>, class Self, class... Args>
    U value_or(this Self&& self, Args&&... args);

template <class U = remove_cvref_t<T>, class Self, class X, class... Args>
    U value_or(this Self&& self, initializer_list<X> il, Args&&... args);
  \end{codeblock}
\end{addedblock}
  \begin{addedblock}
  \begin{codeblock}
    namespace std {
      template <class T>
      class optional<T&> {
      public:
        using value_type = T&;

        // \ref{optional.ctor}, constructors
        constexpr optional() noexcept;
        constexpr optional(nullopt_t) noexcept;
        constexpr optional(const optional&) = default;
        constexpr optional(optional&&) noexcept = default;
        template<class U>
        constexpr explicit(@\seebelow@) optional(U&&);
        template<class U>
        constexpr explicit(@\seebelow@) optional(const optional<U>&);

        // \ref{optional.dtor}, destructor
        constexpr ~optional();

        // \ref{optional.assign}, assignment
        constexpr optional& operator=(nullopt_t) noexcept;
        constexpr optional& operator=(const optional&) noexcept = default;
        constexpr optional& operator=(optional&&) noexcept = default;
        template<class U = T> constexpr optional& operator=(U&&);
        template<class U> constexpr optional& operator=(const optional<U>&);

        template<class U> constexpr T& emplace(U&&);

        // \ref{optional.swap}, swap
        constexpr void swap(optional&) noexcept;

        // \ref{optional.observe}, observers
        constexpr T* operator->() const noexcept;
        constexpr T& operator*() const noexcept;
        constexpr explicit operator bool() const noexcept;
        constexpr bool has_value() const noexcept;
        constexpr const T& value() const;                                 // freestanding-deleted

        // Without P3091
        template<class U> constexpr T value_or(U&&) const;

        // With P3091
        template <class U = remove_cv_t<T>, class... Args>
          U value_or(Args&&...) const;
        template <class U = remove_cv_t<T>, class X, class... Args>
          U constexpr value_or(initializer_list<X>, Args&&...) const;

        // \ref{optional.monadic}, monadic operations
        template<class F> constexpr auto and_then(F&& f) const;
        template<class F> constexpr auto transform(F&& f) const;
        template<class F> constexpr optional or_else(F&& f) const;

        // \ref{optional.mod}, modifiers
        constexpr void reset() noexcept;

      private:
        T *val;         // \expos
      };
    }
  \end{codeblock}

  \pnum
  Any instance of \tcode{optional<T\&>} at any given time either refers to a value or does not refer to a value.
  When an instance of \tcode{optional<T\&>} \defnx{refers to a value}{refers to a value!\idxcode{optional}},
  it means that an object of type \tcode{T}, referred to as the optional object's \defnx{referred to value}{referred to value!\idxcode{optional}},
  is pointed to from the storage of the optional object.
  When an object of type \tcode{optional<T\&>} is contextually converted to \tcode{bool},
  the conversion returns \tcode{true} if the object refers to a value;
  otherwise the conversion returns \tcode{false}.

  \pnum
  When an \tcode{optional<T\&>} object refers to a value,
  member \tcode{val} points to the referred to object.
  \end{addedblock}

  From P3091

At the end of 22.5.3.6 [optional.observe] in the Working Draft, modify the definition of value_or:

\begin{removedblock}
  \begin{itemdecl}
  template<class U> constexpr T value_or(U&&) const &;
  \end{itemdecl}
  Description ...

  \begin{itemdecl}
  template<class U> constexpr T value_or(U&&) &&;
  \end{itemdecl}
  Description ...
\end{removedblock}

\begin{addedblock}
  \begin{itemdecl}
template <class U = remove_cvref_t<T>, class Self, class... Args>
U value_or(this Self&& self, Args&&... args);
\end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
    is_constructible_v<U, decltype(*std::forward<Self>(self))> \&\&
is_constructible_v<U, Args...> is true. If U is a reference type, then sizeof...(Args) is 1 and, for v being a value of the single type in Args, the initialization U u(v); is well formed and does not bind u to a temporary whose lifetime is extended (6.7.7 [class.temporary]).

    \pnum
    \effects
    Equivalent to:

return self.has_value() ? U(*std::forward<Self>(self)) : U(std::forward<Args>(args)...);
\end{itemdescr}

  \begin{itemdecl}
template <class U = remove_cvref_t<T>, class Self, class X, class... Args>
    U value_or(this Self&& self, initializer_list<X> il, Args&&... args);
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
 ! is_reference_v<U> \&\& is_constructible_v<U, initializer_list<X>, Args...> \&\&
is_constructible_v<U, decltype(*std::forward<Self>(self))> is true.

    \pnum
    \effects
 Equivalent to:

return self.has_value() ? U(*std::forward<Self>(self)) : U(il, std::forward<Args>(args)...);
\end{itemdescr}
\end{addedblock}

  \rSec3[optional.ctor]{Constructors}

  \indexlibraryctor{optional}%
  \begin{itemdecl}
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \ensures
    \tcode{*this} does not refer to a value.

    \pnum
    \remarks
    For every object type \tcode{T} these constructors are constexpr constructors\iref{dcl.constexpr}.
  \end{itemdescr}

  \indexlibraryctor{optional}%
  \begin{itemdecl}
    constexpr optional(const optional& rhs) noexecpt = default;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \effects
    Initializes \tcode{val} with the value of \tcode{rhs.val}.

    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \throws
    Nothing

    \pnum
    \remarks
    This constructor is trivial.

  \end{itemdescr}

  \indexlibraryctor{optional}%
  \begin{itemdecl}
    constexpr optional(optional&& rhs) noexcept = default;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum

    \pnum
    \effects
    Initializes \tcode{val} with the value of \tcode{rhs.val}.
    \tcode{rhs.has_value()} is unchanged.

    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \remarks
    This constructor is trivial.

  \end{itemdescr}



  \indexlibraryctor{optional}%
  \begin{itemdecl}
    template<class U = T> constexpr explicit(@\seebelow@) optional(U&& v);
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
    \item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}, and
    \item if \tcode{T} is \cv{} \tcode{bool},
      \tcode{remove_cvref_t<U>} is not a specialization of \tcode{optional}.
    \end{itemize}

    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
    \end{itemize}

    \pnum
    \effects
    Direct-non-list-initializes the referred to value with \tcode{addressof(v)}.

    \pnum
    \ensures
    \tcode{*this} refers to a value.

  \end{itemdescr}

  \indexlibraryctor{optional}%
  \begin{itemdecl}
    template<class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs);
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
    \item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}.
    \end{itemize}

    \pnum
    \effects
    If \tcode{rhs} refers to a value,
    initializes \tcode{val} with the value of\tcode{addressof(rhs.value()))}.

    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
      !is_convertible_v<U, T>
    \end{codeblock}

  \end{itemdescr}


  \rSec3[optional.dtor]{Destructor}

  \indexlibrarydtor{optional}%
  \begin{itemdecl}
    constexpr ~optional() = default;
  \end{itemdecl}
\begin{itemdescr}
\pnum
\remarks
This destructor is trivial.
\end{itemdescr}

  \rSec3[optional.assign]{Assignment}

  \indexlibrarymember{operator=}{optional}%
  \begin{itemdecl}
    optional& operator=(nullopt_t) noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \ensures
    \tcode{*this} does not refer to a value.

    \pnum
    \returns
    \tcode{*this}.
  \end{itemdescr}

  \indexlibrarymember{operator=}{optional}%
  \begin{itemdecl}
    constexpr optional<T>& operator=(const optional& rhs) noexcept = default;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \returns
    \tcode{*this}.

  \end{itemdescr}

  \indexlibrarymember{operator=}{optional}%
  \begin{itemdecl}
    constexpr optional& operator=(optional&& rhs) noexcept = default;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \returns
    \tcode{*this}.
  \end{itemdescr}

  \indexlibrarymember{operator=}{optional}%
  \begin{itemdecl}
    template<class U = T> constexpr optional<T>& operator=(U&& v);
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
    \item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}
    \item \tcode{conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>>} is \tcode{false}
    \end{itemize}

    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
    \end{itemize}

    \pnum
    \effects
    Assigns the \tcode{val} the value of \tcode{addressof(v)}.

    \pnum
    \ensures
    \tcode{*this} refers to a value.

  \end{itemdescr}

  \indexlibrarymember{operator=}{optional}%
  \begin{itemdecl}
    template<class U> constexpr optional<T>& operator=(const optional<U>& rhs);
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
    \end{itemize}

    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \returns
    \tcode{*this}.

  \end{itemdescr}


  \indexlibrarymember{emplace}{optional}%
  \begin{itemdecl}
    template <class U = T> optional& emplace(U&& u) noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \constraints
    \begin{itemize}
    \item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}, and
    \item if \tcode{T} is \cv{} \tcode{bool},
      \tcode{remove_cvref_t<U>} is not a specialization of \tcode{optional}.
    \end{itemize}
    \pnum
    \effects
    Assigns \tcode{*this} \tcode{forward<U>(u)}

    \pnum
    \ensures
    \tcode{*this} refers to a value.

  \end{itemdescr}

  \rSec3[optional.swap]{Swap}

  \indexlibrarymember{swap}{optional}%
  \begin{itemdecl}
    constexpr void swap(optional& rhs) noexcept;
  \end{itemdecl}

  \begin{itemdescr}

    \pnum
    \effects
    *this and *rhs will refer to each others initial referred to objects.

  \end{itemdescr}


  \rSec3[optional.observe]{Observers}

  \indexlibrarymember{operator->}{optional}%
  \begin{itemdecl}
    constexpr T* operator->() const noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \returns
    \tcode{val}.

    \pnum
    \remarks
    These functions are constexpr functions.
  \end{itemdescr}

  \indexlibrarymember{operator*}{optional}%
  \begin{itemdecl}
    constexpr T&  operator*() const noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \expects
    \tcode{*this} refers to a value.

    \pnum
    \returns
    \tcode{*val}.

    \pnum
    \remarks
    These functions are constexpr functions.
  \end{itemdescr}

  \indexlibrarymember{operator bool}{optional}%
  \begin{itemdecl}
    constexpr explicit operator bool() const noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \returns
    \tcode{true} if and only if \tcode{*this} refers to a value.

    \pnum
    \remarks
    This function is a constexpr function.
  \end{itemdescr}

  \indexlibrarymember{has_value}{optional}%
  \begin{itemdecl}
    constexpr bool has_value() const noexcept;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \returns
    \tcode{true} if and only if \tcode{*this} refers to a value.

    \pnum
    \remarks
    This function is a constexpr function.
  \end{itemdescr}

  \indexlibrarymember{value}{optional}%
  \begin{itemdecl}
    constexpr T& value() const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
      if (has_value())
          return *value_;
      throw bad_optional_access();
    \end{codeblock}
  \end{itemdescr}

  Without P3091
  \indexlibrarymember{value_or}{optional}%
  \begin{itemdecl}
    template<class U> constexpr T value_or(U&& v) const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
    \tcode{is_constructible_v<add_lvalue_reference_t<T>, decltype(v)>} is \tcode{true}.

    \pnum
    \effects
    Equivalent to:

    return has_value() ? U(**this) : U(std::forward<Args>(args)...);
  \end{itemdescr}

  With P3091
  \indexlibrarymember{value_or}{optional}%
  \begin{itemdecl}
  template <class U = T, class... Args>
    U value_or(Args&&...args) const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
    is_constructible_v<U, decltype(**this)> \&\& is_constructible_v<U, Args...>
is true. If U is a reference type, then sizeof...(Args) is 1 and, for v being a value of the single type in Args, the initialization U u(v); is well formed and does not bind u to a temporary whose lifetime is extended (6.7.7 [class.temporary]).

\pnum
\effects
Equivalent to:

return has_value() ? U(**this) : U(std::forward<Args>(args)...);
  \end{itemdescr}

  \begin{itemdecl}
template <class U = remove_cv_t<T>, class X, class... Args>
  U constexpr value_or(initializer_list<X> il, Args&&...) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
   ! is_reference_v<U> \&\& is_constructible_v<U, initializer_list<X>, Args...> \&\&
is_constructible_v<U, decltype(**this)> is true.

  \pnum
    \effects
   Equivalent to:

   return has_value() ? U(**this) : U(il, std::forward<Args>(args)...);
\end{itemdescr}

  \rSec3[optional.monadic]{Monadic operations}

  \indexlibrarymember{and_then}{optional}
  \begin{itemdecl}
    template<class F> constexpr auto and_then(F&& f) const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    Let \tcode{U} be \tcode{invoke_result_t<F, T\&>}.

    \pnum
    \mandates
    \tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
      return has_value() ? invoke(forward<F>(f), value()) : result(nullopt);
    \end{codeblock}
  \end{itemdescr}

  \indexlibrarymember{transform}{optional}
  \begin{itemdecl}
    template<class F> constexpr auto transform(F&& f) const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, T\&>>}.


    \pnum
    \returns
    If \tcode{*this} refers to a value, an \tcode{optional<U>} object
    whose refered to value is the result of
    \tcode{invoke(forward<F>(f), *val)};
    otherwise, \tcode{optional<U>()}.
  \end{itemdescr}

  \indexlibrarymember{or_else}{optional}
  \begin{itemdecl}
    template<class F> constexpr optional or_else(F&& f) const;
  \end{itemdecl}

  \begin{itemdescr}
    \pnum
    \mandates
    \tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
      if (has_value()))
        return value()
      else
        return forward<F>(f)();
      }
    \end{codeblock}
  \end{itemdescr}

  \rSec3[optional.mod]{Modifiers}

  \indexlibrarymember{reset}{optional}%
  \begin{itemdecl}
    constexpr void reset() noexcept;
  \end{itemdecl}

  \begin{itemdescr}

    \pnum
    \ensures
    \tcode{*this} does not refer to a value.
  \end{itemdescr}

\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_optional_ref 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}
