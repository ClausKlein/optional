\rSec1[optional]{Optional objects}

\rSec2[optional.general]{General}

\pnum
Subclause~\ref{optional} describes class template \tcode{optional} that represents
optional objects.
An \defn{optional object} is an
object that contains the storage for another object and manages the lifetime of
this contained object, if any. The contained object may be initialized after
the optional object has been initialized, and may be destroyed before the
optional object has been destroyed. The initialization state of the contained
object is tracked by the optional object.

\rSec2[optional.syn]{Header \tcode{<optional>} synopsis}

\indexheader{optional}%
\begin{codeblock}
// mostly freestanding
#include <compare>              // see \ref{compare.syn}

namespace std {
  // \ref{optional.optional}, class template \tcode{optional} for object types
  template <class T>
  class optional; // partially freestanding

  @\added{// \ref{optional.optionalref}, class template \tcode{optional} for reference types }@
  @\added{template <class T> }@
  @\added{class optional<T\&>; // partially freestanding}@

  template <class T>
  inline constexpr bool ranges::enable_view<optional<T>> = true;
  template <class T>
  inline constexpr auto format_kind<optional<T>> = range_format::disabled;
  @\added{template<class T>}@
  @\added{constexpr bool ranges::enable_borrowed_range<optional<T>> = is_reference_v<T>;}@

  template<class T>
    concept @\defexposconcept{is-derived-from-optional}@ = requires(const T& t) {       // \expos
      []<class U>(const optional<U>&){ }(t);
    };

  // \ref{optional.nullopt}, no-value state indicator
  struct nullopt_t{@\seebelow@};
  inline constexpr nullopt_t nullopt(@\unspec@);

  // \ref{optional.bad.access}, class \tcode{bad_optional_access}
  class bad_optional_access;

  // \ref{optional.relops}, relational operators
  template<class T, class U>
    constexpr bool operator==(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>=(const optional<T>&, const optional<U>&);
  template<class T, @\libconcept{three_way_comparable_with}@<T> U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const optional<U>&);

  // \ref{optional.nullops}, comparison with \tcode{nullopt}
  template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template<class T>
    constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;

  // \ref{optional.comp.with.t}, comparison with \tcode{T}
  template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);
  template<class T, class U>
      requires (!@\exposconcept{is-derived-from-optional}@<U>) && @\libconcept{three_way_comparable_with}@<T, U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const U&);

  // \ref{optional.specalg}, specialized algorithms
  template<class T>
    constexpr void swap(optional<T>&, optional<T>&) noexcept(@\seebelow@);

  template<class T>
    constexpr optional<decay_t<T>> make_optional(T&&);
  template<class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // \ref{optional.hash}, hash support
  template<class T> struct hash;
  template<class T> struct hash<optional<T>>;
}
\end{codeblock}

\rSec2[optional.optional]{Class template \tcode{optional} \added{for object types}}

\rSec3[optional.optional.general]{General}

\indexlibraryglobal{optional}%
\indexlibrarymember{value_type}{optional}%
\begin{codeblock}
namespace std {
  template<class T>
  class optional {
  public:
    using value_type     = T;
    using iterator       = @\impdefnc@;              // see~\ref{optional.iterators}
    using const_iterator = @\impdefnc@;              // see~\ref{optional.iterators}

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&);
    constexpr optional(optional&&) noexcept(@\seebelow@);

    template<class... Args>
      constexpr explicit optional(in_place_t, Args&&...);
    template<class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
    template<class U = remove_cv_t<T>>
      constexpr explicit(@\seebelow@) optional(U&&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>&);
\end{codeblock}
\color{addclr}
\begin{codeblock}
    template<class U>
      constexpr explicit(@\seebelow@) optional(const optional<U&>&);
\end{codeblock}
\color{black}
\begin{codeblock}
    template<class U>
      constexpr explicit(@\seebelow@) optional(optional<U>&&);

    // \ref{optional.dtor}, destructor
    constexpr ~optional();

    // \ref{optional.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;
    constexpr optional& operator=(const optional&);
    constexpr optional& operator=(optional&&) noexcept(@\seebelow@);
    template<class U = remove_cv_t<T>> constexpr optional& operator=(U&&);
    template<class U> constexpr optional& operator=(const optional<U>&);
\end{codeblock}
\color{addclr}
\begin{codeblock}
    template<class U> constexpr optional& operator=(const optional<U&>&);
\end{codeblock}
\color{black}
\begin{codeblock}
    template<class U> constexpr optional& operator=(optional<U>&&);
    template<class... Args> constexpr T& emplace(Args&&...);
    template<class U, class... Args> constexpr T& emplace(initializer_list<U>, Args&&...);

    // \ref{optional.swap}, swap
    constexpr void swap(optional&) noexcept(@\seebelow@);

    // \ref{optional.iterators}, iterator support
    constexpr iterator begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const noexcept;
    constexpr T* operator->() noexcept;
    constexpr const T& operator*() const & noexcept;
    constexpr T& operator*() & noexcept;
    constexpr T&& operator*() && noexcept;
    constexpr const T&& operator*() const && noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T& value() const &;                                 // freestanding-deleted
    constexpr T& value() &;                                             // freestanding-deleted
    constexpr T&& value() &&;                                           // freestanding-deleted
    constexpr const T&& value() const &&;                               // freestanding-deleted
    template<class U = remove_cv_t<T>> constexpr T value_or(U&&) const &;
    template<class U = remove_cv_t<T>> constexpr T value_or(U&&) &&;

    // \ref{optional.monadic}, monadic operations
    template<class F> constexpr auto and_then(F&& f) &;
    template<class F> constexpr auto and_then(F&& f) &&;
    template<class F> constexpr auto and_then(F&& f) const &;
    template<class F> constexpr auto and_then(F&& f) const &&;
    template<class F> constexpr auto transform(F&& f) &;
    template<class F> constexpr auto transform(F&& f) &&;
    template<class F> constexpr auto transform(F&& f) const &;
    template<class F> constexpr auto transform(F&& f) const &&;
    template<class F> constexpr optional or_else(F&& f) &&;
    template<class F> constexpr optional or_else(F&& f) const &;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T* val;         // \expos
  };

  template<class T>
    optional(T) -> optional<T>;
}
\end{codeblock}

\pnum
Any instance of \tcode{optional<T>} at any given time either contains a value or does not contain a value.
When an instance of \tcode{optional<T>} \defnx{contains a value}{contains a value!\idxcode{optional}},
it means that an object of type \tcode{T}, referred to as the optional object's \defnx{contained value}{contained value!\idxcode{optional}},
is nested within\iref{intro.object} the optional object.
When an object of type \tcode{optional<T>} is contextually converted to \tcode{bool},
the conversion returns \tcode{true} if the object contains a value;
otherwise the conversion returns \tcode{false}.

\pnum
When an \tcode{optional<T>} object contains a value,
member \tcode{val} points to the contained value.

\begin{removedblock}
\tcode{T} shall be a  type
other than \cv{} \tcode{in_place_t} or \cv{} \tcode{nullopt_t}
that meets the \oldconcept{Destructible} requirements (cpp17.destructible).
\end{removedblock}

\begin{addedblock}
\pnum
A type \tcode{X} is a \defnx{valid element type}{valid element type!\idxcode{optional}} for \tcode{optional} if \tcode{remove_cv_t<X>} is an lvalue reference type,
or a complete non-array object type, and \tcode{remove_cvref_t<X>} is a type other than \tcode{in_place_t} or \tcode{nullopt_t}.

\pnum
\tcode{T} shall be an object type that is valid element type for \tcode{optional} and meets the \oldconcept{Destructible} requirements (cpp17.destructible).
\end{addedblock}

\rSec3[optional.ctor]{Constructors}

\pnum
The exposition-only variable template \exposid{converts-from-any-cvref}
is used by some constructors for \tcode{optional}.
\begin{codeblock}
template<class T, class W>
constexpr bool @\exposid{converts-from-any-cvref}@ =  // \expos
  disjunction_v<is_constructible<T, W&>, is_convertible<W&, T>,
                is_constructible<T, W>, is_convertible<W, T>,
                is_constructible<T, const W&>, is_convertible<const W&, T>,
                is_constructible<T, const W>, is_convertible<const W, T>>;
\end{codeblock}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} does not contain a value.

\pnum
\remarks
No contained value is initialized.
For every object type \tcode{T} these constructors are constexpr constructors\iref{dcl.constexpr}.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value
with \tcode{*rhs}.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor is defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true}.
If \tcode{is_trivially_copy_constructible_v<T>} is \tcode{true},
this constructor is trivial.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true}.

\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value
with \tcode{std::move(*rhs)}.
\tcode{rhs.has_value()} is unchanged.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The exception specification is equivalent to
\tcode{is_nothrow_move_constructible_v<T>}.
If \tcode{is_trivially_move_constructible_v<T>} is \tcode{true},
this constructor is trivial.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class... Args> constexpr explicit optional(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, Args...>} is \tcode{true}.

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{std::forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor is a constexpr constructor.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U, class... Args>
  constexpr explicit optional(in_place_t, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true}.

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{il, std::forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor is a constexpr constructor.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U = remove_cv_t<T>> constexpr explicit(@\seebelow@) optional(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U>} is \tcode{true},
\item \tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false},
\item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}, and
\item if \tcode{T} is \cv{} \tcode{bool},
\tcode{remove_cvref_t<U>} is not a specialization of \tcode{optional}.
\end{itemize}

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{std::forward<U>(v)}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s selected constructor is a constexpr constructor,
this constructor is a constexpr constructor.
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<U, T>
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true}, and
\item if \tcode{T} is not \cv{} \tcode{bool},
\tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false}.
\end{itemize}

\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value with \tcode{*rhs}.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<const U&, T>
\end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U> constexpr explicit(@\seebelow@) optional(const optional<U&>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U\&>} is \tcode{true}, and
\item if \tcode{T} is not \cv{} \tcode{bool},
\tcode{\exposid{converts-from-any-cvref}<T, optional<U\&>>} is \tcode{false}.
\end{itemize}

\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value with \tcode{*rhs}.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<U&, T>
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U> constexpr explicit(@\seebelow@) optional(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\begin{addedblock}
\item \tcode{is_reference_v<U>} is \tcode{false},
\end{addedblock}
\item \tcode{is_constructible_v<T, U>} is \tcode{true}, and
\item if \tcode{T} is not \cv{} \tcode{bool},
\tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false}.
\end{itemize}

\pnum
\effects
If \tcode{rhs} contains a value,
direct-non-list-initializes the contained value with \tcode{std::move(*rhs)}.
\tcode{rhs.has_value()} is unchanged.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<U, T>
\end{codeblock}
\end{itemdescr}

\rSec3[optional.dtor]{Destructor}

\rSec3[optional.assign]{Assignment}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional<T>& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} contains a value, calls \tcode{val->T::\~T()} to destroy the contained value; otherwise no effect.

\pnum
\ensures
\tcode{*this} does not contain a value.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional<T>& operator=(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tref{optional.assign.copy}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional\&)} effects}{optional.assign.copy}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
direct-non-list-initializes the contained value with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s copy constructor, no effect.
If an exception is thrown during the call to \tcode{T}'s copy assignment,
the state of its contained value is as defined by the exception safety guarantee of \tcode{T}'s copy assignment.
This operator is defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true} and
\tcode{is_copy_assignable_v<T>} is \tcode{true}.
If \tcode{is_trivially_copy_constructible_v<T> \&\&}
\tcode{is_trivially_copy_assignable_v<T> \&\&}
\tcode{is_trivially_destructible_v<T>} is \tcode{true},
this assignment operator is trivial.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional& operator=(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_move_assignable_v<T>} is \tcode{true}.

\pnum
\effects
See \tref{optional.assign.move}.
The result of the expression \tcode{rhs.has_value()} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional\&\&)} effects}{optional.assign.move}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{std::move(*rhs)} to the contained value &
direct-non-list-initializes the contained value with \tcode{std::move(*rhs)} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
The exception specification is equivalent to:
\begin{codeblock}
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T>
\end{codeblock}

\pnum
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s move constructor,
the state of \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move constructor.
If an exception is thrown during the call to \tcode{T}'s move assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move assignment.
If \tcode{is_trivially_move_constructible_v<T> \&\&}
\tcode{is_trivially_move_assignable_v<T> \&\&}
\tcode{is_trivially_destructible_v<T>} is \tcode{true},
this assignment operator is trivial.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U = remove_cv_t<T>> constexpr optional<T>& operator=(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false},
\item \tcode{conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>>} is \tcode{false},
\item \tcode{is_constructible_v<T, U>} is \tcode{true}, and
\item \tcode{is_assignable_v<T\&, U>} is \tcode{true}.
\end{itemize}

\pnum
\effects
If \tcode{*this} contains a value, assigns \tcode{std::forward<U>(v)} to the contained value; otherwise direct-non-list-initializes the contained value with \tcode{std::forward<U>(v)}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged. If an exception is thrown during the call to \tcode{T}'s constructor, the state of \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s constructor. If an exception is thrown during the call to \tcode{T}'s assignment, the state of \tcode{*val} and \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> constexpr optional<T>& operator=(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\begin{addedblock}
\item \tcode{is_reference_v<U>} is \tcode{false},
\end{addedblock}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, const U\&>} is \tcode{true},
\item \tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}

\pnum
\effects
See \tref{optional.assign.copy.templ}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional<U>\&)} effects}{optional.assign.copy.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
direct-non-list-initializes the contained value with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\begin{addedblock}
\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> constexpr optional<T>& operator=(const optional<U&>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U\&>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, U\&>} is \tcode{true},
\item \tcode{\exposid{converts-from-any-cvref}<T, optional<U\&>>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U\&>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U\&>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U\&>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U\&>\&\&>} is \tcode{false}.
\end{itemize}

\pnum
\effects
See \tref{optional.assign.refcopy.templ}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional<U\&>\&)} effects}{optional.assign.refcopy.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
direct-non-list-initializes the contained value with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}
\end{addedblock}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> constexpr optional<T>& operator=(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\begin{addedblock}
\item \tcode{is_reference_v<U>} is \tcode{false},
\end{addedblock}
\item \tcode{is_constructible_v<T, U>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, U>} is \tcode{true},
\item \tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}

\pnum
\effects
See \tref{optional.assign.move.templ}.
The result of the expression \tcode{rhs.has_value()} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional<U>\&\&)} effects}{optional.assign.move.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{std::move(*rhs)} to the contained value &
direct-non-list-initializes the contained value with \tcode{std::move(*rhs)} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class... Args> constexpr T& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_constructible_v<T, Args...>} is \tcode{true}.

\pnum
\effects
Calls \tcode{*this = nullopt}. Then direct-non-list-initializes the contained value
with \tcode{std::forward\brk{}<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class U, class... Args> constexpr T& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true}.

\pnum
\effects
Calls \tcode{*this = nullopt}. Then direct-non-list-initializes the contained value with
\tcode{il, std::\brk{}forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
\end{itemdescr}


\rSec3[optional.swap]{Swap}

\rSec3[optional.iterators]{Iterator support}

\rSec3[optional.observe]{Observers}

\rSec3[optional.monadic]{Monadic operations}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(*\exposid{val})>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), *@\exposid{val}@);
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(std::move(*\exposid{val}))>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), std::move(*@\exposid{val}@));
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, decltype(*\exposid{val})>>}.

\pnum
\mandates
\begin{removedblock}
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
\end{removedblock}
\begin{addedblock}
\tcode{U} is valid element type for optional.
\end{addedblock}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), *@\exposid{val}@));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), *\exposid{val})};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\tcode{remove_cv_t<invoke_result_t<F, decltype(std::move(*\exposid{val}))>>}.

\pnum
\mandates
\begin{removedblock}
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
\end{removedblock}
\begin{addedblock}
\tcode{U} is valid element type for optional.
\end{addedblock}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), std::move(*@\exposid{val}@)));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), std::move(*\exposid{val}))};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{copy_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return *this;
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{move_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return std::move(*this);
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\rSec3[optional.mod]{Modifiers}

\begin{addedblock}
\rSec2[optional.optionalref]{Class template \tcode{optional} for reference types}

\rSec3[optional.optionalref.general]{General}
\begin{codeblock}
namespace std {
  template<class T>
  class optional<T&> {
    public:
      using value_type     = T;
      using iterator       = @\impdefnc@; // see~\ref{optionalref.iterators}

    public:
      // \ref{optionalref.ctor}, constructors
      constexpr optional() noexcept;
      constexpr optional(nullopt_t) noexcept;
      constexpr optional(const optional& rhs) noexcept = default;

      template <class Arg>
      constexpr explicit optional(in_place_t, Arg&& arg);

      template <class U> constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);

      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>&&& rhs) noexcept(@\seebelow@)

      constexpr ~optional() = default;

      // \ref{optionalref.assign}, assignment
      constexpr optional& operator=(nullopt_t) noexcept;
      constexpr optional& operator=(const optional& rhs) noexcept = default;

      template <class U> constexpr optional& emplace(U&& u) noexcept(@\seebelow@);

      // \ref{optionalref.swap}, swap
      constexpr void swap(optional& rhs) noexcept;

      // \ref{optional.iterators}, iterator support
      constexpr iterator begin() const noexcept;
      constexpr iterator end() const noexcept;

      // \ref{optionalref.observe}, observers
      constexpr T*       operator->() const noexcept;
      constexpr T&       operator*() const noexcept;
      constexpr explicit operator bool() const noexcept;
      constexpr bool     has_value() const noexcept;
      constexpr T&       value() const;                                // freestanding-deleted
      template <class U> constexpr remove_cv_t<T> value_or(U&& u) const;

      // \ref{optionalref.monadic}, monadic operations
      template <class F> constexpr auto and_then(F&& f) const;
      template <class F> constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
      template <class F> constexpr optional or_else(F&& f) const;

      // \ref{optionalref.mod}, modifiers
      constexpr void reset() noexcept;

    private:
      T* val; // \expos
  };

}
\end{codeblock}

\pnum
An instance of optional<T\&> contains a value if \tcode{\exposid{val} != nullptr} is \tcode{true}.

\rSec3[optionalref.ctor]{Constructors}

\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to
\begin{codeblock}
@\exposid{val} = nullptr;
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
template <class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, remove_cv_t<Arg>>} is \tcode{true}
  \item \tcode{reference_constructs_from_temporary_v<T\&, Arg>)} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Initializes \exposid{val} with \tcode{addressof(static_cast<T\&>(std::forward<Arg>(arg)))}

\end{itemdescr}

\begin{itemdecl}
template <class U>
  constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
  \item \tcode{(is_same_v<remove_cvref_t<U>, in_place_t>)} is \tcode{false}
  \item \tcode{(is_same_v<remove_cvref_t<U>, optional>)} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Initializes \tcode{\exposid{val}} with \tcode{addressof(static_cast<T\&>(std::forward<U>(u)))}.

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}



\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U\&>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(rhs.value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U&, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U&>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U&>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, const U\&>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(rhs.value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}


  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<const U&, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, const U&>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, const U&>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(std::move(rhs).value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(const optional<U>&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, const U>} is \tcode{true}
  \item \tcode{std::is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}
  \item \tcode{std::is_same_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
if (rhs.has_value()) {
    @\exposid{val}@ = addressof(static_cast<T&>(std::move(rhs).value()));
} else {
    @\exposid{val}@ = nullptr;
}
  \end{codeblock}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
!is_convertible_v<const U, T&>
  \end{codeblock}
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, const U>
  \end{codeblock}
  This constructor is defined as deleted if
  \begin{codeblock}
reference_constructs_from_temporary_v<T&, const U>
  \end{codeblock}
  is \tcode{true}
\end{itemdescr}


\rSec3[optionalref.assign]{Assignment}

\begin{itemdecl}
constexpr optional& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
@\exposid{val}@ = nullptr;
  \end{codeblock}

  \pnum
  \returns
  \tcode{*this}.
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr T& emplace(U&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
    \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}
    \item \tcode{reference_constructs_from_temporary_v<T\&, U>} is \tcode{false}
  \end{itemize}

  \pnum
  \effects
  Assigns \tcode{\exposid{val}} \tcode{addressof(static_cast<T\&>(std::forward<U>(u)))}

  \pnum
  \remarks
  The expression inside \keyword{noexcept} is equivalent to:
  \begin{codeblock}
is_nothrow_constructible_v<T&, U>
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.swap]{Swap}

\begin{itemdecl}
constexpr void swap(optional& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
std::swap(@\exposid{val}@, rhs.@\exposid{val}@);
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.iterators]{Iterator support}
\begin{itemdecl}
using iterator = @\impdef@;
\end{itemdecl}

\begin{itemdescr}
\pnum
These types
model \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous},
meet the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}, and
meet the requirements for constexpr iterators\iref{iterator.requirements.general},
with value type \tcode{remove_cv_t<T>}.
The reference type is \tcode{T\&} for \tcode{iterator}.

\pnum
All requirements on container iterators\iref{container.reqmts} apply to
\tcode{optional::iterator}.

\end{itemdescr}


\begin{itemdecl}
constexpr iterator begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  If \tcode{has_value()} is \tcode{true},
  an iterator referring to the referred to value.
  Otherwise, a past-the-end iterator value.

\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{begin() + has_value()}.
\end{itemdescr}



\rSec3[optionalref.observe]{Observers}

\begin{itemdecl}
constexpr T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
   \pnum
   \expects
   \tcode{has_value()} is \tcode{true}

   \pnum
   \returns
   \tcode{*\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}
\end{itemdescr}

\begin{itemdecl}
constexpr bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}
\end{itemdescr}

\begin{itemdecl}
constexpr T& value() const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
  return *@\exposid{val}@;
}
throw bad_optional_access();
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr T value_or(U&& u) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \begin{itemize}
    \item \tcode{is_constructible_v<std::remove_cv_t<T>, T\&>} is \tcode{true}.
    \item \tcode{is_convertible_v<U, std::remove_cv_t<T>>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return remove_cv_t<T>(*@\exposid{val}@);
} else {
    return std::forward<U>(u);
}
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.monadic]{Monadic operations}

\begin{itemdecl}
template <class F>
constexpr auto and_then(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{invoke_result_t<F, T\&>}.

  \pnum
  \mandates
  \tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return invoke(std::forward<F>(f), *@\exposid{val}@);
} else {
    return remove_cvref_t<U>();
}
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, T\&>>}.

  \pnum
  \mandates
  \tcode{U} is a valid element type for optional.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value()) {
    return optional<U>{invoke(std::forward<F>(f), *@\exposid{val}@)};
} else {
    return optional<U>{};
}
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr optional or_else(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
    if (has_value()) {
        return *@\exposid{val}@;
    } else {
        return std::forward<F>(f)();
    }
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.mod]{Modifiers}

\begin{itemdecl}
constexpr void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to
  \begin{codeblock}
  @\exposid{val}@ = nullptr;
  \end{codeblock}
  \tcode{\exposid{val}} does not refer to a value.
\end{itemdescr}

\end{addedblock}

\rSec2[optional.nullopt]{No-value state indicator}
\rSec2[optional.bad.access]{Class \tcode{bad_optional_access}}
\rSec2[optional.relops]{Relational operators}
\rSec2[optional.specalg]{Specialized algorithms}
\indexlibrarymember{swap}{optional}%
\begin{itemdecl}
template<class T>
  constexpr void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{removedblock}
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_swappable_v<T>} is \tcode{true}.
\end{removedblock}

\begin{addedblock}
  \constraints
    \tcode{is_reference_v<T> || (is_move_constructible_v<T> \&\& is_swappable_v<T>)} is \tcode{true}.
\end{addedblock}

\pnum
\effects
Calls \tcode{x.swap(y)}.
\end{itemdescr}


\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T> constexpr optional<decay_t<T>> make_optional(T&& v);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\constraints
The call to \tcode{make_optional} does not use
an explicit \grammarterm{template-argument-list} that
begins with a type \grammarterm{template-argument}.
\end{addedblock}

\pnum
\returns
\tcode{optional<decay_t<T>>(std::forward<T>(v))}.
\end{itemdescr}

\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T, class...Args>
  constexpr optional<T> make_optional(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\mandates
\tcode{is_reference_v<T>} is false.
\end{addedblock}

\pnum
\effects
Equivalent to: \tcode{return optional<T>(in_place, std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T, class U, class... Args>
  constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\mandates
\tcode{is_reference_v<U>} is \tcode{false}.
\end{addedblock}

\pnum
\effects
Equivalent to: \tcode{return optional<T>(in_place, il, std::forward<Args>(args)...);}
\end{itemdescr}


\rSec2[optional.hash]{Hash support}
\indexlibrarymember{hash}{optional}%
\begin{itemdecl}
template<class T> struct hash<optional<T>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The specialization \tcode{hash<optional<T>>} is enabled\iref{unord.hash}
if and only if \added{\tcode{is_reference_v<T>} is false and} \tcode{hash<remove_const_t<T>>} is enabled.
When enabled, for an object \tcode{o} of type \tcode{optional<T>},
if \tcode{o.has_value() == true}, then \tcode{hash<optional<T>>()(o)}
evaluates to the same value as \tcode{hash<remove_const_t<T>>()(*o)};
otherwise it evaluates to an unspecified value.
The member functions are not guaranteed to be \keyword{noexcept}.
\end{itemdescr}

\begin{addedblock}
\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_optional_ref 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}
\end{addedblock}
