\rSec1[optional]{Optional objects}

\rSec2[optional.general]{General}

\pnum
Subclause~\ref{optional} describes class template \tcode{optional} that represents
optional objects.
An \defn{optional object} is an
object that contains the storage for another object and manages the lifetime of
this contained object, if any. The contained object may be initialized after
the optional object has been initialized, and may be destroyed before the
optional object has been destroyed. The initialization state of the contained
object is tracked by the optional object.

\rSec2[optional.syn]{Header \tcode{<optional>} synopsis}

\indexheader{optional}%
\begin{codeblock}
// mostly freestanding
#include <compare>              // see \ref{compare.syn}

namespace std {
  // \ref{optional.optional}, class template \tcode{optional} for object types
  template <class T>
  class optional; // partially freestanding

  @\added{// \ref{optional.optionalref}, class template \tcode{optional} for reference types }@
  @\added{template <class T> }@
  @\added{class optional<T\&>; // partially freestanding}@

  template <class T>
  inline constexpr bool ranges::enable_view<optional<T>> = true;
  template <class T>
  inline constexpr auto format_kind<optional<T>> = range_format::disabled;

  template<class T>
    concept @\defexposconcept{is-derived-from-optional}@ = requires(const T& t) {       // \expos
      []<class U>(const optional<U>&){ }(t);
    };

  // \ref{optional.nullopt}, no-value state indicator
  struct nullopt_t{@\seebelow@};
  inline constexpr nullopt_t nullopt(@\unspec@);

  // \ref{optional.bad.access}, class \tcode{bad_optional_access}
  class bad_optional_access;

  // \ref{optional.relops}, relational operators
  template<class T, class U>
    constexpr bool operator==(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>=(const optional<T>&, const optional<U>&);
  template<class T, @\libconcept{three_way_comparable_with}@<T> U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const optional<U>&);

  // \ref{optional.nullops}, comparison with \tcode{nullopt}
  template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template<class T>
    constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;

  // \ref{optional.comp.with.t}, comparison with \tcode{T}
  template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);
  template<class T, class U>
      requires (!@\exposconcept{is-derived-from-optional}@<U>) && @\libconcept{three_way_comparable_with}@<T, U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const U&);

  // \ref{optional.specalg}, specialized algorithms
  template<class T>
    constexpr void swap(optional<T>&, optional<T>&) noexcept(@\seebelow@);

  template<class T>
    constexpr optional<@\seebelow@> make_optional(T&&);
  template<class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // \ref{optional.hash}, hash support
  template<class T> struct hash;
  template<class T> struct hash<optional<T>>;
}
\end{codeblock}

\rSec2[optional.optional]{Class template \tcode{optional} \added{for object types}}

\rSec3[optional.optional.general]{General}

\indexlibraryglobal{optional}%
\indexlibrarymember{value_type}{optional}%
\begin{codeblock}
namespace std {
  template<class T>
  class optional {
  public:
    using value_type     = T;
    using iterator       = @\impdefnc@;              // see~\ref{optional.iterators}
    using const_iterator = @\impdefnc@;              // see~\ref{optional.iterators}

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&);
    constexpr optional(optional&&) noexcept(@\seebelow@);

    template<class... Args>
      constexpr explicit optional(in_place_t, Args&&...);
    template<class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
    template<class U = T>
      constexpr explicit(@\seebelow@) optional(U&&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(optional<U>&&);

    // \ref{optional.dtor}, destructor
    constexpr ~optional();

    // \ref{optional.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;
    constexpr optional& operator=(const optional&);
    constexpr optional& operator=(optional&&) noexcept(@\seebelow@);
    template<class U = T> constexpr optional& operator=(U&&);
    template<class U> constexpr optional& operator=(const optional<U>&);
    template<class U> constexpr optional& operator=(optional<U>&&);
    template<class... Args> constexpr T& emplace(Args&&...);
    template<class U, class... Args> constexpr T& emplace(initializer_list<U>, Args&&...);

    // \ref{optional.swap}, swap
    constexpr void swap(optional&) noexcept(@\seebelow@);

    // \ref{optional.iterators}, iterator support
    constexpr iterator begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const noexcept;
    constexpr T* operator->() noexcept;
    constexpr const T& operator*() const & noexcept;
    constexpr T& operator*() & noexcept;
    constexpr T&& operator*() && noexcept;
    constexpr const T&& operator*() const && noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T& value() const &;                                 // freestanding-deleted
    constexpr T& value() &;                                             // freestanding-deleted
    constexpr T&& value() &&;                                           // freestanding-deleted
    constexpr const T&& value() const &&;                               // freestanding-deleted
    template<class U> constexpr T value_or(U&&) const &;
    template<class U> constexpr T value_or(U&&) &&;

    // \ref{optional.monadic}, monadic operations
    template<class F> constexpr auto and_then(F&& f) &;
    template<class F> constexpr auto and_then(F&& f) &&;
    template<class F> constexpr auto and_then(F&& f) const &;
    template<class F> constexpr auto and_then(F&& f) const &&;
    template<class F> constexpr auto transform(F&& f) &;
    template<class F> constexpr auto transform(F&& f) &&;
    template<class F> constexpr auto transform(F&& f) const &;
    template<class F> constexpr auto transform(F&& f) const &&;
    template<class F> constexpr optional or_else(F&& f) &&;
    template<class F> constexpr optional or_else(F&& f) const &;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T *val;         // \expos
  };

  template<class T>
    optional(T) -> optional<T>;
}
\end{codeblock}

\pnum
Any instance of \tcode{optional<T>} at any given time either contains a value or does not contain a value.
When an instance of \tcode{optional<T>} \defnx{contains a value}{contains a value!\idxcode{optional}},
it means that an object of type \tcode{T}, referred to as the optional object's \defnx{contained value}{contained value!\idxcode{optional}},
is allocated within the storage of the optional object.
Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.
When an object of type \tcode{optional<T>} is contextually converted to \tcode{bool},
the conversion returns \tcode{true} if the object contains a value;
otherwise the conversion returns \tcode{false}.

\pnum
When an \tcode{optional<T>} object contains a value,
member \tcode{val} points to the contained value.

\pnum
\tcode{T} shall be a \added{non-array object} type
other than \cv{} \tcode{in_place_t} or \cv{} \tcode{nullopt_t}
that meets the \oldconcept{Destructible} requirements (\tref{cpp17.destructible}).

\rSec3[optional.ctor]{Constructors}


\rSec3[optional.dtor]{Destructor}

\rSec3[optional.assign]{Assignment}


\rSec3[optional.swap]{Swap}


\rSec3[optional.iterators]{Iterator support}

\rSec3[optional.observe]{Observers}

\rSec3[optional.monadic]{Monadic operations}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(*val)>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), *val);
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(std::move(*val))>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), std::move(*val));
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, decltype(*val)>>}.

\pnum
\mandates
\tcode{U} is a \added{reference or} non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), *val));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), *val)};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\tcode{remove_cv_t<invoke_result_t<F, decltype(std::move(*val))>>}.

\pnum
\mandates
\tcode{U} is a \added{reference or} non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), std::move(*val)));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), std::move(*val))};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{copy_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return *this;
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}<>} and
\tcode{T} models \libconcept{move_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return std::move(*this);
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\rSec3[optional.mod]{Modifiers}

\begin{addedblock}
\rSec2[optional.optionalref]{Class template \tcode{optional} for reference types}

\rSec3[optional.optionalref.general]{General}
\begin{codeblock}
namespace std {
  template<class T>
  class optional<T&> {
    public:
      using value_type     = T;
      using iterator       = @\impdefnc@; // see~\ref{optionalref.iterators}

    public:
      // \ref{optionalref.ctor}, constructors
      constexpr optional() noexcept;
      constexpr optional(nullopt_t) noexcept;
      constexpr optional(const optional& rhs) noexcept = default;

      template <class Arg>
      constexpr explicit optional(in_place_t, Arg&& arg);

      template <class U> constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);

      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@)
      template <class U> constexpr explicit(@\seebelow@) optional(const optional<U>&&& rhs) noexcept(@\seebelow@)

      constexpr ~optional() = default;

      // \ref{optionalref.assign}, assignment
      constexpr optional& operator=(nullopt_t) noexcept;
      constexpr optional& operator=(const optional& rhs) noexcept = default;

      template <class U> constexpr optional& emplace(U&& u) noexcept(@\seebelow@);

      // \ref{optionalref.swap}, swap
      constexpr void swap(optional& rhs) noexcept;

      // \ref{optional.iterators}, iterator support
      constexpr iterator begin() const noexcept;
      constexpr iterator end() const noexcept;

      // \ref{optionalref.observe}, observers
      constexpr T*       operator->() const noexcept;
      constexpr T&       operator*() const noexcept;
      constexpr explicit operator bool() const noexcept;
      constexpr bool     has_value() const noexcept;
      constexpr T&       value() const;                                // freestanding-deleted
      template <class U> constexpr remove_cv_t<T> value_or(U&& u) const;

      // \ref{optionalref.monadic}, monadic operations
      template <class F> constexpr auto and_then(F&& f) const;
      template <class F> constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
      template <class F> constexpr optional or_else(F&& f) const;

      // \ref{optionalref.mod}, modifiers
      constexpr void reset() noexcept;

    private:
      T* val; // \expos
  };

}
\end{codeblock}
\rSec3[optionalref.ctor]{Constructors}

\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} does not refer to a value.

\pnum
\remarks
    For all \tcode{T\&} these constructors are constexpr constructors\iref{dcl.constexpr}.
\end{itemdescr}


\begin{itemdecl}
template <class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, Arg>} is \tcode{true}
  \end{itemize}
  \pnum
  \mandates
    \begin{itemize}
    \item \tcode{reference_converts_from_temporary_v<R, Arg>} is \tcode{false}
    \end{itemize}
  \pnum
  \ensures
  \tcode{*this} refers to the T created by conversion from \tcode{arg}

\end{itemdescr}

\begin{itemdecl}
template <class U>
  constexpr explicit(@\seebelow@) optional(U&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{!\exposconcept{is-derived-from-optional}<decay_t<U>>} is \tcode{true}
  \end{itemize}
    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
    \end{itemize}

    \pnum
    \effects
    Direct-non-list-initializes \tcode{val} with \tcode{addressof(u)}.

    \pnum
    \ensures
    \tcode{*this} refers to a value.\end{itemdescr}

  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
    !is_convertible_v<U, T>
  \end{codeblock}

\begin{itemdecl}
template <class U>
constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \end{itemize}
  \pnum
  \ensures
  If \tcode{rhs.has_value()} is \tcode{true}, \tcode{*this} refers to the same value, otherwise, \tcode{*this} does not refer to a value.
  \pnum
  \remarks
  The expression inside \keyword{explicit} is equivalent to:
  \begin{codeblock}
    !is_convertible_v<U, T>
  \end{codeblock}

\end{itemdescr}


\rSec3[optionalref.assign]{Assignment}

\begin{itemdecl}
constexpr optional& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \ensures
  \tcode{*this} does not refer to a value.

  \pnum
  \returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template <class U = T>
constexpr optional& operator=(U&& u);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{!\exposconcept{is-derived-from-optional}<decay_t<U>>} is \tcode{true}
  \end{itemize}

  \pnum
  \mandates
  \begin{itemize}
  \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
  \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
  \end{itemize}

  \pnum
  \effects
  Assigns the \tcode{val} the value of \tcode{addressof(v)}.

  \pnum
  \ensures
  \tcode{*this} refers to a value.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr optional& operator=(const optional<U>& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{is_lvalue_reference<U>::value>} is \tcode{true}
    \end{itemize}

    \pnum
    \ensures
    \tcode{rhs.has_value() == this->has_value()}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr optional& operator=(optional<U>&& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
    \item \tcode{is_constructible_v<add_lvalue_reference_t<T>, U>} is \tcode{true}
    \item \tcode{reference_converts_from_temporary_v<R, Arg>} is \tcode{false}
    \end{itemize}

    \pnum
    \ensures
    If \tcode{rhs.has_value()} is \tcode{true}, \tcode{*this} refers to the value obtained by converting the \tcode{rhs} referred to value to a \tcode{T\&}, otherwise, \tcode{*this} does not refer to a value

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr optional& emplace(U&& u) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{!\exposconcept{is-derived-from-optional}<decay_t<U>>} is \tcode{true}
  \end{itemize}

  \pnum
  \effects
  Assigns \tcode{*this} \tcode{forward<U>(u)}

  \pnum
  \ensures
  \tcode{*this} refers to a value.
\end{itemdescr}


\rSec3[optionalref.swap]{Swap}

\begin{itemdecl}
constexpr void swap(optional& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  *this and *rhs will refer to each others initial referred to objects.
\end{itemdescr}


\rSec3[optionalref.iterators]{Iterator support}
\begin{itemdecl}
using iterator = @\impdef@;
using const_iterator = @\impdef@;
\end{itemdecl}

\begin{itemdescr}
\pnum
These types
model \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous},
meet the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}, and
meet the requirements for constexpr iterators\iref{iterator.requirements.general},
with value type \tcode{remove_cv_t<T>}.
The reference type is \tcode{T\&} for \tcode{iterator} and
\tcode{const T\&} for \tcode{const_iterator}.

\pnum
All requirements on container iterators\iref{container.reqmts} apply to
\tcode{optional::iterator} and \tcode{optional::\linebreak{}const_iterator} as well.

\end{itemdescr}


\begin{itemdecl}
constexpr iterator begin() noexcept;
constexpr const_iterator begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  If \tcode{has_value()} is \tcode{true},
  an iterator referring to the referred to value.
  Otherwise, a past-the-end iterator value.

\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() noexcept;
constexpr const_iterator end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{begin() + has_value()}.
\end{itemdescr}



\rSec3[optionalref.observe]{Observers}

\begin{itemdecl}
constexpr T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{val}.

\end{itemdescr}

\begin{itemdecl}
constexpr T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
   \pnum
   \expects
   \tcode{*this} refers to a value.

   \pnum
   \returns
   \tcode{*val}.

\end{itemdescr}

\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{true} if and only if \tcode{*this} refers to a value.
\end{itemdescr}

\begin{itemdecl}
constexpr bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{true} if and only if \tcode{*this} refers to a value.
\end{itemdescr}

\begin{itemdecl}
constexpr T& value() const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
    if (has_value())
      return *value_;
    throw bad_optional_access();
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr T value_or(U&& u) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \tcode{is_constructible_v<add_lvalue_reference_t<T>, decltype(v)>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \tcode{return has_value() ? U(**this) : U(std::forward<Args>(u));}
\end{itemdescr}


\rSec3[optionalref.monadic]{Monadic operations}

\begin{itemdecl}
template <class F>
constexpr auto and_then(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{invoke_result_t<F, T\&>}.

  \pnum
  \mandates
  \tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
    return has_value() ? invoke(forward<F>(f), value()) : result(nullopt);
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, T\&>>}.


  \pnum
  \returns
  If \tcode{*this} refers to a value, an \tcode{optional<U>} object
  whose refered to value is the result of
  \tcode{invoke(forward<F>(f), *val)};
  otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr optional or_else(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \mandates
  \tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
    if (has_value()))
        return value()
    else
        return forward<F>(f)();
  \end{codeblock}
\end{itemdescr}


\rSec3[optionalref.mod]{Modifiers}

\begin{itemdecl}
constexpr void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \ensures
  \tcode{*this} does not refer to a value.
\end{itemdescr}

\end{addedblock}

\rSec2[optional.nullopt]{No-value state indicator}
\rSec2[optional.bad.access]{Class \tcode{bad_optional_access}}
\rSec2[optional.relops]{Relational operators}
\rSec2[optional.specalg]{Specialized algorithms}
\rSec2[optional.hash]{Hash support}

\begin{addedblock}
\Sec2[version.syn]{Feature-test macro}
Add the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_optional_ref 20XXXXL // also in <ranges>, <tuple>, <utility>
\end{codeblock}
\end{addedblock}
