\documentclass[a4paper,10pt,oneside,openany,final,article]{memoir}
\input{common}
\settocdepth{chapter}
\usepackage{minted}
\usepackage{fontspec}
\setromanfont{Source Serif Pro}
\setsansfont{Source Sans Pro}
% \setmonofont{Source Code Pro}

\begin{document}
\title{std::optional<T\&>}
\author{
  Steve Downey \small<\href{mailto:sdowney@gmail.com}{sdowney@gmail.com}> \\
  Peter Sommerlad \small<\href{mailto:peter.cpp@sommerlad.ch}{peter.cpp@sommerlad.ch}> \\
}
\date{} %unused. Type date explicitly below.
\maketitle

\begin{flushright}
  \begin{tabular}{ll}
    Document \#: & P2988R6 \\
    Date: & \today \\
    Project: & Programming Language C++ \\
    Audience: & LEWG
  \end{tabular}
\end{flushright}

\begin{abstract}
  We propose to fix a hole intentionally left in \tcode{std::optional} ---

  An optional over a reference such that the post condition on assignment is independent of the engaged state, always producing a rebound reference, and assigning a \tcode{U} to a \tcode{T} is disallowed by \tcode{static_assert} if a \tcode{U} can not be bound to a \tcode{T\&}.
\end{abstract}

\tableofcontents*

\chapter*{Changes Since Last Version}

\begin{itemize}
  \item \textbf{Changes since R5}
  \begin{itemize}
  \item refref specialization
  \item fix monadic constraints on base template
  \end{itemize}
\item \textbf{Changes since R4}
  \begin{itemize}
  \item feature test macro
  \item value_or updates from P3091
  \end{itemize}
\item \textbf{Changes since R3}
  \begin{itemize}
  \item make_optional discussion - always value
  \item value_or discussion - always value
  \end{itemize}
\end{itemize}

\chapter{Comparison table}
\section{Using a raw pointer result for an element search function}

This is the convention the C++ core guidelines suggest, to use a raw pointer for representing optional non-owning references.
However, there is a user-required check against `nullptr`, no type safety meaning no safety against mis-interpreting such a raw pointer, for example by using pointer arithmetic on it.

\begin{tabular}{ lr }
  \begin{minipage}[t]{0.45\columnwidth}
    \begin{minted}[fontsize=\small]{c++}
      Cat* cat = find_cat("Fido");
      if (cat!=nullptr) { return doit(*cat); }


    \end{minted}
  \end{minipage}
  &
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{minted}[fontsize=\small]{c++}
        std::optional<Cat&> cat = find_cat("Fido");
        return cat.and_then(doit);

      \end{minted}
    \end{minipage}
\end{tabular}

\section{returning result of an element search function via a (smart) pointer}

The disadvantage here is that \tcode{std::experimental::observer_ptr<T>} is both non-standard and not well named, therefore this example uses \tcode{shared_ptr} that would have the advantage of avoiding dangling through potential lifetime extension.
However, on the downside is still the explicit checks against the \tcode{nullptr} on the client side, failing so risks undefined behavior.

  \begin{tabular}{ lr }
  \begin{minipage}[t]{0.45\columnwidth}
    \begin{minted}[fontsize =\small]{c++}
std::shared_ptr<Cat> cat = find_cat("Fido");
if (cat != nullptr) {/* ... */}

    \end{minted}
  \end{minipage}
  &
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{minted}[fontsize=\small]{c++}
std::optional<Cat&> cat = find_cat("Fido");
cat.and_then([](Cat& thecat){/* ... */}

      \end{minted}
    \end{minipage}
  \end{tabular}
  \section{returning result of an element search function via an iterator}

  This might be the obvious choice, for example, for associative containers, especially since their iterator stability guarantees.
  However, returning such an iterator will leak the underlying container type as well necessarily requires one to know the sentinel of the container to check for the not-found case.

  \begin{tabular}{ lr }
  \begin{minipage}[t]{0.45\columnwidth}
    \begin{minted}[fontsize=\small]{c++}
std::map<std::string, Cat>::iterator cat
        = find_cat("Fido");
if (cat != theunderlyingmap.end()){/* ... */}

    \end{minted}
  \end{minipage}
  &
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{minted}[fontsize=\small]{c++}
std::optional<Cat&> cat
        = find_cat("Fido");
cat.and_then([](Cat& thecat){/* ... */}

      \end{minted}
    \end{minipage}
  \end{tabular}

  \section{Using an optional<T*> as a substitute for optional<T\&>}

This approach adds another level of indirection and requires two checks to take a definite action.

  \begin{tabular}{ lr }
  \begin{minipage}[t]{0.45\columnwidth}
    \begin{minted}[fontsize=\small]{c++}
//Mutable optional
std::optional<Cat*> c = find_cat("Fido");
if (c) {
    if (*c) {
      *c.value() = Cat("Fynn", color::orange);
    }
}

    \end{minted}
  \end{minipage}
  &
    \begin{minipage}[t]{0.45\columnwidth}
      \begin{minted}[fontsize=\small]{c++}
std::optional<Cat&> c = find_cat("Fido");
if (c) {
  *c = Cat("Fynn", color::orange);
}

//or

o.transform([](Cat& c){
  c = Cat("Fynn", color::orange);
});
        \end{minted}
      \end{minipage}
\end{tabular}

\chapter{Motivation}
Other than the standard library's implementation of optional, optionals holding references are common. The desire for such a feature is well understood, and many optional types in commonly used libraries provide it, with the semantics proposed here.
One standard library implementation already provides an implementation of \tcode{std::optional<T\&>} but disables its use, because the standard forbids it.

The research in JeanHeyd Meneide's _References for Standard Library Vocabulary Types - an optional case study._ \cite{P1683R0} shows conclusively that rebind semantics are the only safe semantic as assign through on engaged is too bug-prone. Implementations that attempt assign-through are abandoned. The standard library should follow existing practice and supply an \tcode{optional<T\&>} that rebinds on assignment.

Additional background reading on \tcode{optional<T\&>} can be found in JeanHeyd Meneide's article _To Bind and Loose a Reference_ \cite{REFBIND}.

In freestanding environments or for safety-critical libraries, an optional type over references is important to implement containers, that otherwise as the standard library either would cause undefined behavior when accessing an non-available element, throw an exception, or silently create the element. Returning a plain pointer for such an optional reference, as the core guidelines suggest, is a non-type-safe solution and doesn't protect in any way from accessing an non-existing element by a \tcode{nullptr} de-reference. In addition, the monadic APIs of \tcode{std::optional} makes is especially attractive by streamlining client code receiving such an optional reference, in contrast to a pointer that requires an explicit nullptr check and de-reference.

There is a principled reason not to provide a partial specialization over \tcode{T\&} as the semantics are in some ways subtly different than the primary template. Assignment may have side-effects not present in the primary, which has pure value semantics. However, I argue this is misleading, as reference semantics often has side-effects. The proposed semantic is similar to what an \tcode{optional<std::reference_wrapper<T>>} provides, with much greater usability.

There are well motivated suggestions that perhaps instead of an \tcode{optional<T\&>} there should be an \tcode{optional_ref<T>} that is an independent primary template. This proposal rejects that, because we need a policy over all sum types as to how reference semantics should work, as optional is a variant over T and monostate. That the library sum type can not express the same range of types as the product type, tuple, is an increasing problem as we add more types logically equivalent to a variant. The template types \tcode{optional} and \tcode{expected} should behave as extensions of \tcode{variant<T, monostate>} and \tcode{variant<T, E>}, or we lose the ability to reason about generic types.

That we can't guarantee from \tcode{std::tuple<Args...>} (product type) that \tcode{std::variant<Args...>} (sum type) is valid, is a problem, and one that reflection can't solve. A language sum type could, but we need agreement on the semantics.

The semantics of a variant with a reference are as if it holds the address of the referent when referring to that referent. All other semantics are worse. Not being able to express a variant<T\&> is inconsistent, hostile, and strictly worse than disallowing it.

Thus, we expect future papers to propose \tcode{std::expected<T\&,E>} and \tcode{std::variant} with the ability to hold references.
The latter can be used as an iteration type over \tcode{std::tuple} elements.


\chapter{Design}

The design is straightforward. The \tcode{optional<T\&>} holds a pointer to the underlying object of type \tcode{T}, or \tcode{nullptr} if the optional is disengaged. The implementation is simple, especially with C++20 and up techniques, using concept constraints. As the held pointer is a primitive regular type with reference semantics, many operations can be defaulted and are \tcode{noexcept} by nature. See \cite{Downey_smd_optional_optional_T} and \cite{rawgithu58:online}. The \tcode{optional<T\&>} implementation is less than 200 lines of code, much of it the monadic functions with identical textual implementations with different signatures and different overloads being called.

In place construction is not supported as it would just be a way of providing immediate life-time issues.

\section{Relational Operations}

The definitions of the relational operators are the same as for the base template. Interoperable comparisons between T and optional<T\&> work as expected. This is not true for the boost optional<T\&>.

\section{make_optional}
Because of existing code, \tcode{make_optional<T\&>} must return optional<T> rather than optional<T\&>. Returning optional<T\&> is consistent and defensible, and a few optional implementations in production make this choice. It is, however, quite easy to construct a make_optional expression that deduces a different category causing possibly dangerous changes to code.

There was some discussion about using library technology to allow selection of the reference overload via the literal spelling \tcode{make_optional<int\&>}. There was anti-consensus to do so. There are existing instances of that spelling that today return an \tcode{optional<T>}, although it is very likely these are mistakes or possibly other optionals. The spelling \tcode{optional<T\&>\{\}} is acceptable as there is no multi-argument emplacement version as there is no location to construct such an instance.

There was also discussion of using \tcode{std::reference_wrapper} to indicate reference use, in analogy with std::tuple. Unfortunately there are existing uses of optional over reference_wrapper as a workaround for lack of reference specialization, and it would be a breaking change for such code.

\section{Trivial construction}
Construction of \tcode{optional<T\&>} should be trivial, because it is straightforward to implement, and \tcode{optional<T>} is trivial. Boost is not.

\section{Value Category Affects value()}
For several implementations there are distinct overloads for functions depending on value category, with the same implementation. However, this makes it very easy to accidentally steal from the underlying referred to object. Value category should be shallow. Thanks to many people for pointing this out. If ``Deducing \tcode{this}'' had been used, the problem would have been much more subtle in code review.

\section{Shallow vs Deep const}

There is some implementation divergence in optionals about deep const for \tcode{optional<T\&>}. That is, can the referred to \tcode{int} be modified through a \tcode{const optional<int\&>}. Does \tcode{operator->()} return an \tcode{int*} or a \tcode{const int*}, and does \tcode{operator*()} return an \tcode{int\&} or a \tcode{const int\&}. I believe it is overall more defensible if the \tcode{const} is shallow as it would be for a \tcode{struct ref {int * p;}} where the constness of the struct ref does not affect if the p pointer can be written through. This is consistent with the rebinding behavior being proposed.

Where deeper constness is desired, \tcode{optional<const T\&>} would prevent non const access to the underlying object.

\section{Conditional Explicit}
As in the base template, \tcode{explicit} is made conditional on the type used to construct the optional. \tcode{explicit(!std::is_convertible_v<U, T>)}. This is not present in boost::optional, leading to differences in construction between braced initialization and = that can be surprising.

\section{value_or}
\removed{Have \tcode{value_or} return a \tcode{T\&}. Check that the supplied value can be bound to a T\&.}

After extensive discussion, it seems there is no particularly wonderful solution for \tcode{value_or} that does not involve a time machine. Implementations of optionals that support reference semantics diverge over the return type, and the current one is arguably wrong, and should use something based on \tcode{common_reference_type}, which of course did not exist when \tcode{optional} was standardized.

The weak consensus is to return a \tcode{T} from \tcode{optional<T\&>::value_or} as this is least likely to cause issues. There was at least one strong objection to this choice, but all other choices had more objections. The author intends to propose free functions \tcode{reference_or}, \tcode{value_or}, \tcode{or_invoke}, and \tcode{yield_if} over all types modeling optional-like, \tcode{concept std::maybe}, in the next revision of \cite{P1255R12}. This would cover \tcode{optional}, \tcode{expected}, and pointer types.

Having \tcode{value_or} return by value also allows the common case of using a literal as the alternative to be expressed concisely.

\section{Compiler Explorer Playground}

See \url{https://godbolt.org/z/n5oooK58W} for a playground with relevant Google Test functions and various optional implementations made available for cross reference.

\chapter{Proposal}

Add lvalue and rvalue reference specializations for the std::optional template.

\chapter{Wording}

The wording here cross references and adopts the wording in \cite{P3091R2}.


\begin{wording}

\include{new-optional}

\end{wording}

\chapter{Impact on the standard}

A pure library extension, affecting no other parts of the library or language.

The proposed changes are relative to the current working draft \cite{N4910}.

\chapter*{Document history}

\begin{itemize}
\item \textbf{Changes since R1}
  \begin{itemize}
  \item Design points called out
  \end{itemize}
\item \textbf{Changes since R0}
  \begin{itemize}
  \item Wording Updates
  \end{itemize}
\end{itemize}

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{wg21,mybiblio}


\backmatter
\chapter*{Implementation}

\begin{minted}{c++}
// Beman/Optional26/optional.hpp                                     -*-C++-*-
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef BEMAN_OPTIONAL26_OPTIONAL_HPP
#define BEMAN_OPTIONAL26_OPTIONAL_HPP

#include <compare>
#include <concepts>
#if defined(__cpp_lib_format_ranges)
#include <format>
#endif
#include <functional>
#include <ranges>
#include <type_traits>
#include <utility>

#include <Beman/Optional26/detail/iterator.hpp>

namespace beman::optional26 {
// Using declarations of traits used
using std::add_lvalue_reference_t;
using std::add_rvalue_reference_t;
using std::addressof;
using std::compare_three_way_result_t;
using std::conjunction_v;
using std::construct_at;
using std::convertible_to;
using std::decay_t;
using std::destroy_at;
using std::initializer_list;
using std::invoke;
using std::invoke_result_t;
using std::is_array_v;
using std::is_assignable_v;
using std::is_constructible_v;
using std::is_convertible_v;
using std::is_copy_assignable_v;
using std::is_copy_constructible_v;
using std::is_lvalue_reference;
using std::is_move_assignable_v;
using std::is_move_constructible_v;
using std::is_nothrow_constructible_v;
using std::is_nothrow_move_constructible;
using std::is_nothrow_move_constructible_v;
using std::is_nothrow_swappable;
using std::is_object_v;
using std::is_reference_v;
using std::is_rvalue_reference;
using std::is_same;
using std::is_same_v;
using std::is_scalar;
using std::is_swappable_v;
using std::is_trivially_copy_assignable_v;
using std::is_trivially_copy_constructible_v;
using std::is_trivially_destructible_v;
using std::is_trivially_move_assignable_v;
using std::is_trivially_move_constructible_v;
using std::remove_cv_t;
using std::remove_cvref_t;
using std::strong_ordering;
using std::three_way_comparable_with;
using std::to_address;

namespace detail {
template <typename T, typename U>
concept optional_eq_rel = requires(const T& t, const U& u) {
    { t == u } -> convertible_to<bool>;
};

template <typename T, typename U>
concept optional_ne_rel = requires(const T& t, const U& u) {
    { t != u } -> convertible_to<bool>;
};

template <typename T, typename U>
concept optional_lt_rel = requires(const T& t, const U& u) {
    { t < u } -> convertible_to<bool>;
};

template <typename T, typename U>
concept optional_gt_rel = requires(const T& t, const U& u) {
    { t > u } -> convertible_to<bool>;
};

template <typename T, typename U>
concept optional_le_rel = requires(const T& t, const U& u) {
    { t <= u } -> convertible_to<bool>;
};

template <typename T, typename U>
concept optional_ge_rel = requires(const T& t, const U& u) {
    { t >= u } -> convertible_to<bool>;
};
} // namespace detail

struct in_place_t {
    explicit in_place_t() = default;
};

inline constexpr in_place_t in_place{};

} // namespace beman::optional26

namespace beman::optional26 {
template <class T>
class optional; // partially freestanding
} // namespace beman::optional26

namespace std { // trait specializations
// Since P3168R2: Give std::optional Range Support.
template <class T>
inline constexpr bool ranges::enable_view<beman::optional26::optional<T>> =
    true;

// TODO: document why this is needed.
template <class T>
inline constexpr bool
    ranges::enable_borrowed_range<beman::optional26::optional<T&>> = true;

// Since P3168R2: Give std::optional Range Support.
#if defined(__cpp_lib_format_ranges)
template <class T>
inline constexpr auto format_kind<beman::optional26::optional<T>> =
    range_format::disabled;
#endif

} // namespace std

namespace beman::optional26 {
template <class T>
concept is_derived_from_optional = requires(const T& t) { // exposition only
    []<class U>(const optional<U>&) {}(t);
};

// \ref{optional.nullopt}, no-value state indicator
struct nullopt_t {
    // Used for constructing nullopt.
    enum class Tag { tag };

    // Must be constexpr for nullopt_t to be literal.
    explicit constexpr nullopt_t(Tag) noexcept {}
};

/// Tag to disengage optional objects.
inline constexpr nullopt_t nullopt{nullopt_t::Tag::tag};

// \ref{optional.bad.access}, class bad_optional_access
class bad_optional_access;

// \ref{optional.relops}, relational operators
template <typename T, typename U>
constexpr bool operator==(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_eq_rel<T, U>;
template <typename T, typename U>
constexpr bool operator!=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_ne_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_lt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_gt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_le_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_ge_rel<T, U>;
template <class T, three_way_comparable_with<T> U>
constexpr compare_three_way_result_t<T, U> operator<=>(const optional<T>&,
                                                       const optional<U>&);

// \ref{optional.nullops}, comparison with \tcode{nullopt}
template <class T>
constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
template <class T>
constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;

// \ref{optional.comp.with.t}, comparison with \tcode{T}
template <typename T, typename U>
constexpr bool operator==(const optional<T>& lhs, const U& rhs)
    requires detail::optional_eq_rel<T, U>;
template <typename T, typename U>
constexpr bool operator==(const T& lhs, const optional<U>& rhs)
    requires detail::optional_eq_rel<T, U>;
template <typename T, typename U>
constexpr bool operator!=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_ne_rel<T, U>;
template <typename T, typename U>
constexpr bool operator!=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_ne_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<(const optional<T>& lhs, const U& rhs)
    requires detail::optional_lt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<(const T& lhs, const optional<U>& rhs)
    requires detail::optional_lt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>(const optional<T>& lhs, const U& rhs)
    requires detail::optional_gt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>(const T& lhs, const optional<U>& rhs)
    requires detail::optional_gt_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_le_rel<T, U>;
template <typename T, typename U>
constexpr bool operator<=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_le_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_ge_rel<T, U>;
template <typename T, typename U>
constexpr bool operator>=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_ge_rel<T, U>;
template <typename T, typename U>
    requires(!is_derived_from_optional<U>) && three_way_comparable_with<T, U>
constexpr compare_three_way_result_t<T, U> operator<=>(const optional<T>& x,
                                                       const U&           v);

// \ref{optional.specalg}, specialized algorithms
template <class T>
constexpr void swap(optional<T>& x,
                    optional<T>& y) noexcept(noexcept(x.swap(y)))
    requires is_move_constructible_v<T> && is_swappable_v<T>;

template <class T>
constexpr optional<decay_t<T>> make_optional(T&&) noexcept(
    is_nothrow_constructible_v<optional<decay_t<T>>, T>)
    requires is_constructible_v<decay_t<T>, T>;

template <class T, class... Args>
constexpr optional<T>
make_optional(Args&&... args) noexcept(is_nothrow_constructible_v<T, Args...>)
    requires is_constructible_v<T, Args...>;

template <class T, class U, class... Args>
constexpr optional<T>
make_optional(initializer_list<U> il, Args&&... args) noexcept(
    is_nothrow_constructible_v<T, initializer_list<U>&, Args...>)
    requires is_constructible_v<T, initializer_list<U>&, Args...>;

// \ref{optional.hash}, hash support
template <class T>
struct hash;
template <class T>
struct hash<optional<T>>;

/// END [optional.syn]

namespace detail {
template <class T, class U>
concept enable_forward_value =
    is_constructible_v<T, U&&> && !is_same_v<decay_t<U>, in_place_t> &&
    !is_same_v<optional<T>, decay_t<U>>;

template <class T, class U, class Other>
concept enable_from_other =
    is_constructible_v<T, Other> && !is_constructible_v<T, optional<U>&> &&
    !is_constructible_v<T, optional<U>&&> &&
    !is_constructible_v<T, const optional<U>&> &&
    !is_constructible_v<T, const optional<U>&&> &&
    !is_convertible_v<optional<U>&, T> &&
    !is_convertible_v<optional<U>&&, T> &&
    !is_convertible_v<const optional<U>&, T> &&
    !is_convertible_v<const optional<U>&&, T>;

template <class T, class U>
concept enable_assign_forward =
    !is_same_v<optional<T>, decay_t<U>> &&
    !conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>> &&
    is_constructible_v<T, U> && is_assignable_v<T&, U>;

template <class T, class U, class Other>
concept enable_assign_from_other =
    is_constructible_v<T, Other> && is_assignable_v<T&, Other> &&
    !is_constructible_v<T, optional<U>&> &&
    !is_constructible_v<T, optional<U>&&> &&
    !is_constructible_v<T, const optional<U>&> &&
    !is_constructible_v<T, const optional<U>&&> &&
    !is_convertible_v<optional<U>&, T> &&
    !is_convertible_v<optional<U>&&, T> &&
    !is_convertible_v<const optional<U>&, T> &&
    !is_convertible_v<const optional<U>&&, T> &&
    !is_assignable_v<T&, optional<U>&> &&
    !is_assignable_v<T&, optional<U>&&> &&
    !is_assignable_v<T&, const optional<U>&> &&
    !is_assignable_v<T&, const optional<U>&&>;
} // namespace detail

namespace detail {
template <class T>
inline constexpr bool is_optional = false;
template <class T>
inline constexpr bool is_optional<optional<T>> = true;
} // namespace detail

// 22.5.3.1 General[optional.optional.general]

template <class T>
class optional {
    static_assert((!is_same_v<T, remove_cv_t<in_place_t>>) &&
                  (!is_same_v<remove_cv_t<T>, nullopt_t>));
    static_assert(is_object_v<T> && !is_array_v<T>);

  public:
    using value_type = T;
    // Since P3168R2: Give std::optional Range Support.
    using iterator =
        detail::contiguous_iterator<T,
                                    optional>; // see~\ref{optional.iterators}
    using const_iterator =
        detail::contiguous_iterator<const T,
                                    optional>; // see~\ref{optional.iterators}

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional& rhs)
        requires is_copy_constructible_v<T> &&
                 (!is_trivially_copy_constructible_v<T>);
    constexpr optional(const optional&)
        requires is_copy_constructible_v<T> &&
                     is_trivially_copy_constructible_v<T>
    = default;
    constexpr optional(optional&& rhs) noexcept(
        is_nothrow_move_constructible_v<T>)
        requires is_move_constructible_v<T> &&
                 (!is_trivially_move_constructible_v<T>);
    constexpr optional(optional&&)
        requires is_move_constructible_v<T> &&
                     is_trivially_move_constructible_v<T>
    = default;

    template <class... Args>
    constexpr explicit optional(in_place_t, Args&&... args)
        requires is_constructible_v<T, Args...>;

    template <class U, class... Args>
    constexpr explicit optional(in_place_t,
                                initializer_list<U> il,
                                Args&&... args)
        requires is_constructible_v<T, initializer_list<U>&, Args&&...>;

    template <class U = T>
    constexpr explicit(!is_convertible_v<U, T>) optional(U&& u)
        requires detail::enable_forward_value<T, U>;

    template <class U>
    constexpr explicit(!is_convertible_v<U, T>)
        optional(const optional<U>& rhs)
        requires detail::enable_from_other<T, U, const U&> &&
                 is_convertible_v<const U&, T>;

    template <class U>
    constexpr explicit(!is_convertible_v<U, T>)
        optional(const optional<U>& rhs)
        requires detail::enable_from_other<T, U, const U&> &&
                 (!is_convertible_v<const U&, T>);

    template <class U>
    constexpr explicit(!is_convertible_v<U, T>) optional(optional<U>&& rhs)
        requires detail::enable_from_other<T, U, U&&> &&
                 is_convertible_v<U&&, T>;

    template <class U>
    constexpr explicit(!is_convertible_v<U, T>) optional(optional<U>&& rhs)
        requires detail::enable_from_other<T, U, U&&> &&
                 (!is_convertible_v<U &&, T>);

    // \ref{optional.dtor}, destructor
    constexpr ~optional()
        requires is_trivially_destructible_v<T>
    = default;

    constexpr ~optional()
        requires(!is_trivially_destructible_v<T>);

    // \ref{optional.assign}, assignment
    constexpr optional& operator=(const optional& rhs)
        requires is_copy_constructible_v<T> && is_copy_assignable_v<T> &&
                 (!is_trivially_copy_assignable_v<T>);

    constexpr optional& operator=(const optional&)
        requires is_copy_constructible_v<T> && is_copy_assignable_v<T> &&
                     is_trivially_copy_constructible_v<T> &&
                     is_trivially_copy_assignable_v<T>
    = default;

    constexpr optional&
    operator=(optional&& rhs) noexcept(is_nothrow_move_constructible_v<T>)
        requires is_move_constructible_v<T> && is_move_assignable_v<T> &&
                 (!is_trivially_move_assignable_v<T>);

    constexpr optional& operator=(optional&&)
        requires is_move_constructible_v<T> && is_move_assignable_v<T> &&
                     is_trivially_move_constructible_v<T> &&
                     is_trivially_move_assignable_v<T>
    = default;

    template <class U = T>
    constexpr optional& operator=(U&& u)
        requires detail::enable_assign_forward<T, U>;

    template <class U>
    constexpr optional& operator=(const optional<U>& rhs)
        requires detail::enable_assign_from_other<T, U, const U&>;

    template <class U>
    constexpr optional& operator=(optional<U>&& rhs)
        requires detail::enable_assign_from_other<T, U, U>;

    template <class... Args>
    constexpr T& emplace(Args&&... args);

    template <class U, class... Args>
    constexpr T& emplace(initializer_list<U> il, Args&&... args);

    // \ref{optional.swap}, swap
    constexpr void
    swap(optional& rhs) noexcept(is_nothrow_move_constructible<T>::value &&
                                 is_nothrow_swappable<T>::value);

    // \ref{optional.iterators}, iterator support
    constexpr iterator       begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator       end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const;
    constexpr T*       operator->();
    constexpr T&       operator*() &;
    constexpr const T& operator*() const&;
    constexpr T&&      operator*() &&;
    constexpr explicit operator bool() const noexcept;
    constexpr bool     has_value() const noexcept;
    constexpr T&       value() &;
    constexpr const T& value() const&;
    constexpr T&&      value() &&;
    template <class U>
    constexpr T value_or(U&& u) const&;
    template <class U>
    constexpr T value_or(U&& u) &&;

    // \ref{optional.monadic}, monadic operations
    template <class F>
    constexpr auto and_then(F&& f) &;
    template <class F>
    constexpr auto and_then(F&& f) &&;
    template <class F>
    constexpr auto and_then(F&& f) const&;
    template <class F>
    constexpr auto and_then(F&& f) const&&;
    template <class F>
    constexpr auto transform(F&& f) &;
    template <class F>
    constexpr auto transform(F&& f) &&;
    template <class F>
    constexpr auto transform(F&& f) const&;
    template <class F>
    constexpr auto transform(F&& f) const&&;
    template <class F>
    constexpr optional or_else(F&& f) const&;
    template <class F>
    constexpr optional or_else(F&& f) &&;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    struct empty {};
    union {
        empty _{};
        T     value_;
    };
    bool engaged_ = false;

    template <class... Args>
    constexpr void construct(Args&&... args) {
        construct_at(addressof(value_), std::forward<Args>(args)...);
        engaged_ = true;
    }

    constexpr void hard_reset() noexcept {
        destroy_at(addressof(value_));
        engaged_ = false;
    }
};

class bad_optional_access : public std::exception {
  public:
    bad_optional_access() = default;
    const char* what() const noexcept { return "Optional has no value"; }
};

// \rSec3[optional.ctor]{Constructors}
template <class T>
inline constexpr optional<T>::optional() noexcept : _(), engaged_(false) {}

template <class T>
inline constexpr optional<T>::optional(nullopt_t) noexcept {}

template <class T>
inline constexpr optional<T>::optional(const optional& rhs)
    requires is_copy_constructible_v<T> &&
             (!is_trivially_copy_constructible_v<T>)
{
    if (rhs.has_value()) {

        construct_at(addressof(value_), rhs.value_);
        engaged_ = true;
    }
}

template <class T>
inline constexpr optional<T>::optional(optional&& rhs) noexcept(
    is_nothrow_move_constructible_v<T>)
    requires is_move_constructible_v<T> &&
             (!is_trivially_move_constructible_v<T>)
{
    if (rhs.has_value()) {
        construct_at(addressof(value_), std::move(rhs.value()));
        engaged_ = true;
    }
}

/// Constructs the stored value in-place using the given arguments.
template <class T>
template <class... Args>
inline constexpr optional<T>::optional(in_place_t, Args&&... args)
    requires is_constructible_v<T, Args...>
    : value_(std::forward<Args>(args)...), engaged_(true) {}

template <class T>
template <class U, class... Args>
inline constexpr optional<T>::optional(in_place_t,
                                       initializer_list<U> il,
                                       Args&&... args)
    requires is_constructible_v<T, initializer_list<U>&, Args&&...>
    : value_(il, std::forward<Args>(args)...), engaged_(true) {}

/// Constructs the stored value with `u`.
template <class T>
template <class U>
inline constexpr optional<T>::optional(U&& u)
    requires detail::enable_forward_value<T, U> //&& is_convertible_v<U&&, T>
    : optional(in_place, std::forward<U>(u)) {}

/// Converting copy constructor.
template <class T>
template <class U>
inline constexpr optional<T>::optional(const optional<U>& rhs)
    requires detail::enable_from_other<T, U, const U&> &&
             is_convertible_v<const U&, T>
{
    if (rhs.has_value()) {
        construct_at(addressof(value_), rhs.value());
        engaged_ = true;
    }
}

template <class T>
template <class U>
inline constexpr optional<T>::optional(const optional<U>& rhs)
    requires detail::enable_from_other<T, U, const U&> &&
             (!is_convertible_v<const U&, T>)
{
    if (rhs.has_value()) {
        construct(*rhs);
    }
}

/// Converting move constructor.
template <class T>
template <class U>
inline constexpr optional<T>::optional(optional<U>&& rhs)
    requires detail::enable_from_other<T, U, U&&> && is_convertible_v<U&&, T>
{
    if (rhs.has_value()) {
        construct(std::move(*rhs));
    }
}

template <class T>
template <class U>
inline constexpr optional<T>::optional(optional<U>&& rhs)
    requires detail::enable_from_other<T, U, U&&> &&
             (!is_convertible_v<U &&, T>)
{
    if (rhs.has_value()) {
        construct(std::move(*rhs));
    }
}

// 22.5.3.3 Destructor[optional.dtor]

template <class T>
inline constexpr optional<T>::~optional()
    requires(!is_trivially_destructible_v<T>)
{
    if (has_value())
        destroy_at(addressof(value_));
}

// 22.5.3.4 Assignment[optional.assign]

template <class T>
inline constexpr optional<T>& optional<T>::operator=(const optional<T>& rhs)
    requires is_copy_constructible_v<T> && is_copy_assignable_v<T> &&
             (!is_trivially_copy_assignable_v<T>)
{
    if (!rhs.has_value())
        reset();
    else if (has_value())
        value_ = rhs.value_;
    else
        construct_at(addressof(value_), rhs.value_);
    return *this;
}

template <class T>
inline constexpr optional<T>& optional<T>::operator=(
    optional<T>&& rhs) noexcept(is_nothrow_move_constructible_v<T>)
    requires is_move_constructible_v<T> && is_move_assignable_v<T> &&
             (!is_trivially_move_assignable_v<T>)
{
    if (!rhs.has_value())
        reset();
    else if (has_value())
        value_ = std::move(rhs.value_);
    else
        construct_at(addressof(value_), std::move(rhs.value_));
    return *this;
}

/// Assigns the stored value from `u`, destroying the old value if there
/// was one.
template <class T>
template <class U>
inline constexpr optional<T>& optional<T>::operator=(U&& u)
    requires detail::enable_assign_forward<T, U>
{
    if (has_value()) {
        value_ = std::forward<U>(u);
    } else {
        construct(std::forward<U>(u));
    }

    return *this;
}

/// Converting copy assignment operator.
///
/// Copies the value from `rhs` if there is one. Otherwise resets the
/// stored value in `*this`.
template <class T>
template <class U>
inline constexpr optional<T>& optional<T>::operator=(const optional<U>& rhs)
    requires detail::enable_assign_from_other<T, U, const U&>
{
    if (has_value()) {
        if (rhs.has_value()) {
            value_ = *rhs;
        } else {
            hard_reset();
        }
    }

    else if (rhs.has_value()) {
        construct(*rhs);
    }

    return *this;
}

/// Converting move assignment operator.
///
/// Moves the value from `rhs` if there is one. Otherwise resets the stored
/// value in `*this`.
template <class T>
template <class U>
inline constexpr optional<T>& optional<T>::operator=(optional<U>&& rhs)
    requires detail::enable_assign_from_other<T, U, U>
{
    if (has_value()) {
        if (rhs.has_value()) {
            value_ = std::move(*rhs);
        } else {
            hard_reset();
        }
    }

    else if (rhs.has_value()) {
        construct(std::move(*rhs));
    }

    return *this;
}

/// Constructs the value in-place, destroying the current one if there is
/// one.
template <class T>
template <class... Args>
constexpr T& optional<T>::emplace(Args&&... args) {
    static_assert(is_constructible_v<T, Args&&...>);
    *this = nullopt;
    construct(std::forward<Args>(args)...);
    return value();
}

template <class T>
template <class U, class... Args>
constexpr T& optional<T>::emplace(initializer_list<U> il, Args&&... args) {
    static_assert(is_constructible_v<T, initializer_list<U>&, Args&&...>);
    *this = nullopt;
    construct(il, std::forward<Args>(args)...);
    return value();
}

// 22.5.3.5 Swap[optional.swap]
/// Swaps this optional with the other.
///
/// If neither optionals have a value, nothing happens.
/// If both have a value, the values are swapped.
/// If one has a value, it is moved to the other and the movee is left
/// valueless.
template <class T>
inline constexpr void optional<T>::swap(optional<T>& rhs) noexcept(
    is_nothrow_move_constructible<T>::value &&
    is_nothrow_swappable<T>::value) {
    static_assert(is_move_constructible_v<T>);
    using std::swap;
    if (has_value()) {
        if (rhs.has_value()) {
            swap(value(), *rhs);
        } else {
            construct_at(addressof(rhs.value_), std::move(value_));
            value_.T::~T();
        }
    } else if (rhs.has_value()) {
        construct_at(addressof(value_), std::move(rhs.value_));
        rhs.value_.T::~T();
    }
    swap(engaged_, rhs.engaged_);
}

// 22.5.3.6 Iterator support[optional.iterators]
// Since P3168R2: Give std::optional Range Support.
template <class T>
inline constexpr optional<T>::iterator optional<T>::begin() noexcept {
    return iterator(has_value() ? addressof(value_) : nullptr);
}

template <class T>
inline constexpr optional<T>::const_iterator
optional<T>::begin() const noexcept {
    return const_iterator(has_value() ? addressof(value_) : nullptr);
}
template <class T>
inline constexpr optional<T>::iterator optional<T>::end() noexcept {
    return begin() + has_value();
}

template <class T>
inline constexpr optional<T>::const_iterator
optional<T>::end() const noexcept {
    return begin() + has_value();
}

// 22.5.3.7 Observers[optional.observe]

/// Returns a pointer to the stored value
template <class T>
inline constexpr const T* optional<T>::operator->() const {
    return addressof(value_);
}

template <class T>
inline constexpr T* optional<T>::operator->() {
    return addressof(value_);
}

/// Returns the stored value
template <class T>
inline constexpr T& optional<T>::operator*() & {
    return value_;
}

template <class T>
inline constexpr const T& optional<T>::operator*() const& {
    return value_;
}

template <class T>
inline constexpr T&& optional<T>::operator*() && {
    return std::move(value_);
}

template <class T>
inline constexpr optional<T>::operator bool() const noexcept {
    return engaged_;
}

/// Returns whether or not the optional has a value
template <class T>
inline constexpr bool optional<T>::has_value() const noexcept {
    return engaged_;
}

/// Returns the contained value if there is one, otherwise throws
/// bad_optional_access
template <class T>
inline constexpr T& optional<T>::value() & {
    if (has_value())
        return value_;
    throw bad_optional_access();
}
template <class T>
inline constexpr const T& optional<T>::value() const& {
    if (has_value())
        return value_;
    throw bad_optional_access();
}
template <class T>
inline constexpr T&& optional<T>::value() && {
    if (has_value())
        return std::move(value_);
    throw bad_optional_access();
}

/// Returns the stored value if there is one, otherwise returns `u`
template <class T>
template <class U>
inline constexpr T optional<T>::value_or(U&& u) const& {
    static_assert(is_copy_constructible_v<T> && is_convertible_v<U&&, T>);
    return has_value() ? value() : static_cast<T>(std::forward<U>(u));
}

template <class T>
template <class U>
inline constexpr T optional<T>::value_or(U&& u) && {
    static_assert(is_move_constructible_v<T>);
    static_assert(is_convertible_v<decltype(u), T>,
                  "Must be able to convert u to T");
    return has_value() ? std::move(value())
                       : static_cast<T>(std::forward<U>(u));
}

// 22.5.3.8 Monadic operations[optional.monadic]
template <class T>
template <class F>
constexpr auto optional<T>::and_then(F&& f) & {
    using U = invoke_result_t<F, T&>;
    static_assert(detail::is_optional<remove_cvref_t<U>>);
    if (has_value()) {
        return invoke(std::forward<F>(f), value_);
    } else {
        return remove_cvref_t<U>();
    }
}

template <class T>
template <class F>
constexpr auto optional<T>::and_then(F&& f) && {
    using U = invoke_result_t<F, T&&>;
    static_assert(detail::is_optional<remove_cvref_t<U>>);
    if (has_value()) {
        return invoke(std::forward<F>(f), std::move(value_));
    } else {
        return remove_cvref_t<U>();
    }
}

template <class T>
template <class F>
constexpr auto optional<T>::and_then(F&& f) const& {
    using U = invoke_result_t<F, const T&>;
    static_assert(detail::is_optional<remove_cvref_t<U>>);
    if (has_value()) {
        return invoke(std::forward<F>(f), value_);
    } else {
        return remove_cvref_t<U>();
    }
}

template <class T>
template <class F>
constexpr auto optional<T>::and_then(F&& f) const&& {
    using U = invoke_result_t<F, const T&&>;
    static_assert(detail::is_optional<remove_cvref_t<U>>);
    if (has_value()) {
        return invoke(std::forward<F>(f), std::move(value_));
    } else {
        return remove_cvref_t<U>();
    }
}

/// Carries out some operation on the stored object if there is one.
template <class T>
template <class F>
constexpr auto optional<T>::transform(F&& f) & {
    using U = invoke_result_t<F, T&>;
    static_assert(!is_array_v<U>);
    static_assert(!is_same_v<U, in_place_t>);
    static_assert(!is_same_v<U, nullopt_t>);
    static_assert(is_object_v<U> ||
                  is_reference_v<U>); /// References now allowed
    return (has_value()) ? optional<U>{invoke(std::forward<F>(f), value_)}
                         : optional<U>{};
}

template <class T>
template <class F>
constexpr auto optional<T>::transform(F&& f) && {
    using U = invoke_result_t<F, T&&>;
    static_assert(!is_array_v<U>);
    static_assert(!is_same_v<U, in_place_t>);
    static_assert(!is_same_v<U, nullopt_t>);
    static_assert(is_object_v<U> ||
                  is_reference_v<U>); /// References now allowed
    return (has_value())
               ? optional<U>{invoke(std::forward<F>(f), std::move(value_))}
               : optional<U>{};
}

template <class T>
template <class F>
constexpr auto optional<T>::transform(F&& f) const& {
    using U = invoke_result_t<F, const T&>;
    static_assert(!is_array_v<U>);
    static_assert(!is_same_v<U, in_place_t>);
    static_assert(!is_same_v<U, nullopt_t>);
    static_assert(is_object_v<U> ||
                  is_reference_v<U>); /// References now allowed
    return (has_value()) ? optional<U>{invoke(std::forward<F>(f), value_)}
                         : optional<U>{};
}

template <class T>
template <class F>
constexpr auto optional<T>::transform(F&& f) const&& {
    using U = invoke_result_t<F, const T&>;
    static_assert(!is_array_v<U>);
    static_assert(!is_same_v<U, in_place_t>);
    static_assert(!is_same_v<U, nullopt_t>);
    static_assert(is_object_v<U> ||
                  is_reference_v<U>); /// References now allowed
    return (has_value()) ? optional<U>{invoke(std::forward<F>(f), value_)}
                         : optional<U>{};
}

/// Calls `f` if the optional is empty
template <class T>
template <class F>
constexpr optional<T> optional<T>::or_else(F&& f) const& {
    static_assert(is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>);
    if (has_value())
        return value_;

    return std::forward<F>(f)();
}

template <class T>
template <class F>
constexpr optional<T> optional<T>::or_else(F&& f) && {
    static_assert(is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>);
    if (has_value())
        return std::move(value_);

    return std::forward<F>(f)();
}

// 22.5.3.9 Modifiers[optional.mod]
template <class T>
constexpr void optional<T>::reset() noexcept {
    if constexpr (!is_trivially_destructible_v<T>) {
        if (has_value())
            value_.~T();
    }
    engaged_ = false;
}

// 22.5.4 No-value state indicator[optional.nullopt]

// 22.5.5 Class bad_optional_access[optional.bad.access]

// 22.5.6 Relational operators[optional.relops]
template <typename T, typename U>
constexpr bool operator==(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_eq_rel<T, U>
{
    return static_cast<bool>(lhs) == static_cast<bool>(rhs) &&
           (!lhs || *lhs == *rhs);
}

template <typename T, typename U>
constexpr bool operator!=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_ne_rel<T, U>
{
    return static_cast<bool>(lhs) != static_cast<bool>(rhs) ||
           (static_cast<bool>(lhs) && *lhs != *rhs);
}

template <typename T, typename U>
constexpr bool operator<(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_lt_rel<T, U>
{
    return static_cast<bool>(rhs) && (!lhs || *lhs < *rhs);
}

template <typename T, typename U>
constexpr bool operator>(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_gt_rel<T, U>
{
    return static_cast<bool>(lhs) && (!rhs || *lhs > *rhs);
}

template <typename T, typename U>
constexpr bool operator<=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_le_rel<T, U>
{
    return !lhs || (static_cast<bool>(rhs) && *lhs <= *rhs);
}

template <typename T, typename U>
constexpr bool operator>=(const optional<T>& lhs, const optional<U>& rhs)
    requires detail::optional_ge_rel<T, U>
{
    return !rhs || (static_cast<bool>(lhs) && *lhs >= *rhs);
}

template <typename T, three_way_comparable_with<T> U>
constexpr compare_three_way_result_t<T, U> operator<=>(const optional<T>& x,
                                                       const optional<U>& y) {
    return x && y ? *x <=> *y : bool(x) <=> bool(y);
}

// 22.5.7 Comparison with nullopt[optional.nullops]
template <class T>
constexpr bool operator==(const optional<T>& lhs, nullopt_t) noexcept {
    return !lhs;
}

template <class T>
constexpr strong_ordering operator<=>(const optional<T>& x,
                                      nullopt_t) noexcept {
    return bool(x) <=> false;
}

// 22.5.8 Comparison with T[optional.comp.with.t]
template <typename T, typename U>
constexpr bool operator==(const optional<T>& lhs, const U& rhs)
    requires detail::optional_eq_rel<T, U>
{
    return lhs && *lhs == rhs;
}

template <typename T, typename U>
constexpr bool operator==(const T& lhs, const optional<U>& rhs)
    requires detail::optional_eq_rel<T, U>
{
    return rhs && lhs == *rhs;
}

template <typename T, typename U>
constexpr bool operator!=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_ne_rel<T, U>
{
    return !lhs || *lhs != rhs;
}

template <typename T, typename U>
constexpr bool operator!=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_ne_rel<T, U>
{
    return !rhs || lhs != *rhs;
}

template <typename T, typename U>
constexpr bool operator<(const optional<T>& lhs, const U& rhs)
    requires detail::optional_lt_rel<T, U>
{
    return !lhs || *lhs < rhs;
}

template <typename T, typename U>
constexpr bool operator<(const T& lhs, const optional<U>& rhs)
    requires detail::optional_lt_rel<T, U>
{
    return rhs && lhs < *rhs;
}

template <typename T, typename U>
constexpr bool operator>(const optional<T>& lhs, const U& rhs)
    requires detail::optional_gt_rel<T, U>
{
    return lhs && *lhs > rhs;
}

template <typename T, typename U>
constexpr bool operator>(const T& lhs, const optional<U>& rhs)
    requires detail::optional_gt_rel<T, U>
{
    return !rhs || lhs > *rhs;
}

template <typename T, typename U>
constexpr bool operator<=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_le_rel<T, U>
{
    return !lhs || *lhs <= rhs;
}

template <typename T, typename U>
constexpr bool operator<=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_le_rel<T, U>
{
    return rhs && lhs <= *rhs;
}

template <typename T, typename U>
constexpr bool operator>=(const optional<T>& lhs, const U& rhs)
    requires detail::optional_ge_rel<T, U>
{
    return lhs && *lhs >= rhs;
}

template <typename T, typename U>
constexpr bool operator>=(const T& lhs, const optional<U>& rhs)
    requires detail::optional_ge_rel<T, U>
{
    return !rhs || lhs >= *rhs;
}

template <typename T, typename U>
    requires(!is_derived_from_optional<U>) && three_way_comparable_with<T, U>
constexpr compare_three_way_result_t<T, U> operator<=>(const optional<T>& x,
                                                       const U&           v) {
    return bool(x) ? *x <=> v : strong_ordering::less;
}

// 22.5.9 Specialized algorithms[optional.specalg]

template <class T>
constexpr void swap(optional<T>& lhs,
                    optional<T>& rhs) noexcept(noexcept(lhs.swap(rhs)))
    requires is_move_constructible_v<T> && is_swappable_v<T>
{
    return lhs.swap(rhs);
}

template <class T>
constexpr optional<decay_t<T>> make_optional(T&& t) noexcept(
    is_nothrow_constructible_v<optional<decay_t<T>>, T>)
    requires is_constructible_v<decay_t<T>, T>
{
    return optional<decay_t<T>>{std::forward<T>(t)};
}

template <typename T, typename... Args>
constexpr optional<T>
make_optional(Args&&... args) noexcept(is_nothrow_constructible_v<T, Args...>)
    requires is_constructible_v<T, Args...>
{
    return optional<T>{in_place, std::forward<Args>(args)...};
}

template <typename T, typename U, typename... Args>
constexpr optional<T>
make_optional(initializer_list<U> init_list, Args&&... args) noexcept(
    is_nothrow_constructible_v<T, initializer_list<U>&, Args...>)
    requires is_constructible_v<T, initializer_list<U>&, Args...>
{
    return optional<T>{in_place, init_list, std::forward<Args>(args)...};
}

/****************/
/* optional<T&> */
/****************/

template <class T>
class optional<T&> {
  public:
    using value_type = T&;
    using iterator =
        detail::contiguous_iterator<T,
                                    optional>; // see [optionalref.iterators]
    using const_iterator =
        detail::contiguous_iterator<const T,
                                    optional>; // see [optionalref.iterators]

  public:
    // \ref{optionalref.ctor}, constructors

    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional& rhs) noexcept = default;
    constexpr optional(optional&& rhs) noexcept      = default;
    template <class U = T>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr explicit(!is_convertible_v<U, T>) optional(U&& u) noexcept;
    template <class U>
    constexpr explicit(!is_convertible_v<U, T>)
        optional(const optional<U>& rhs) noexcept;

    // \ref{optionalref.dtor}, destructor
    constexpr ~optional() = default;

    // \ref{optionalref.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;

    constexpr optional& operator=(const optional& rhs) noexcept = default;
    constexpr optional& operator=(optional&& rhs) noexcept      = default;

    template <class U = T>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr optional& operator=(U&& u);

    template <class U>
    constexpr optional& operator=(const optional<U>& rhs) noexcept;

    template <class U>
    constexpr optional& operator=(optional<U>&& rhs) = delete;

    template <class U>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr optional& emplace(U&& u) noexcept;

    // \ref{optionalref.swap}, swap
    constexpr void swap(optional& rhs) noexcept;

    // \ref{optional.iterators}, iterator support
    constexpr iterator       begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator       end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optionalref.observe}, observers
    constexpr T*       operator->() const noexcept;
    constexpr T&       operator*() const noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool     has_value() const noexcept;
    constexpr T&       value() const;
    template <class U>
    constexpr T value_or(U&& u) const;

    // \ref{optionalref.monadic}, monadic operations
    template <class F>
    constexpr auto and_then(F&& f) const;
    template <class F>
    constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&>>;
    template <class F>
    constexpr optional or_else(F&& f) const;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T* value_; // exposition only
};

//  \rSec3[optionalref.ctor]{Constructors}
template <class T>
constexpr optional<T&>::optional() noexcept : value_(nullptr) {}

template <class T>
constexpr optional<T&>::optional(nullopt_t) noexcept : value_(nullptr) {}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&>::optional(U&& u) noexcept : value_(addressof(u)) {
    static_assert(is_constructible_v<add_lvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&");
    static_assert(is_lvalue_reference<U>::value, "U must be an lvalue");
}

template <class T>
template <class U>
constexpr optional<T&>::optional(const optional<U>& rhs) noexcept {
    static_assert(is_constructible_v<add_lvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&");
    if (rhs.has_value())
        value_ = to_address(rhs);
    else
        value_ = nullptr;
}

// \rSec3[optionalref.assign]{Assignment}
template <class T>
constexpr optional<T&>& optional<T&>::operator=(nullopt_t) noexcept {
    value_ = nullptr;
    return *this;
}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&>& optional<T&>::operator=(U&& u) {
    static_assert(is_constructible_v<add_lvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&");
    static_assert(is_lvalue_reference<U>::value, "U must be an lvalue");
    value_ = addressof(u);
    return *this;
}

template <class T>
template <class U>
constexpr optional<T&>&
optional<T&>::operator=(const optional<U>& rhs) noexcept {
    static_assert(is_constructible_v<add_lvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&");
    if (rhs.has_value())
        value_ = to_address(rhs);
    else
        value_ = nullptr;
    return *this;
}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&>& optional<T&>::emplace(U&& u) noexcept {
    return *this = std::forward<U>(u);
}

//   \rSec3[optionalref.swap]{Swap}

template <class T>
constexpr void optional<T&>::swap(optional<T&>& rhs) noexcept {
    std::swap(value_, rhs.value_);
}

// \rSec3[optionalref.iterators]{Iterator Support}
template <class T>
constexpr optional<T&>::iterator optional<T&>::begin() noexcept {
    return iterator(has_value() ? value_ : nullptr);
};

template <class T>
constexpr optional<T&>::const_iterator optional<T&>::begin() const noexcept {
    return const_iterator(has_value() ? value_ : nullptr);
};

template <class T>
constexpr optional<T&>::iterator optional<T&>::end() noexcept {
    return begin() + has_value();
}

template <class T>
constexpr optional<T&>::const_iterator optional<T&>::end() const noexcept {
    return begin() + has_value();
}

// \rSec3[optionalref.observe]{Observers}
template <class T>
constexpr T* optional<T&>::operator->() const noexcept {
    return value_;
}

template <class T>
constexpr T& optional<T&>::operator*() const noexcept {
    return *value_;
}

template <class T>
constexpr optional<T&>::operator bool() const noexcept {
    return value_ != nullptr;
}
template <class T>
constexpr bool optional<T&>::has_value() const noexcept {
    return value_ != nullptr;
}

template <class T>
constexpr T& optional<T&>::value() const {
    if (has_value())
        return *value_;
    throw bad_optional_access();
}

template <class T>
template <class U>
constexpr T optional<T&>::value_or(U&& u) const {
    static_assert(is_copy_constructible_v<T>, "T must be copy constructible");
    static_assert(is_convertible_v<decltype(u), T>,
                  "Must be able to convert u to T");
    return has_value() ? *value_ : std::forward<U>(u);
}

//   \rSec3[optionalref.monadic]{Monadic operations}
template <class T>
template <class F>
constexpr auto optional<T&>::and_then(F&& f) const {
    using U = invoke_result_t<F, T&>;
    static_assert(detail::is_optional<U>, "F must return an optional");
    return (has_value()) ? invoke(std::forward<F>(f), *value_)
                         : remove_cvref_t<U>();
}

template <class T>
template <class F>
constexpr auto
optional<T&>::transform(F&& f) const -> optional<invoke_result_t<F, T&>> {
    using U = invoke_result_t<F, T&>;
    return (has_value()) ? optional<U>{invoke(std::forward<F>(f), *value_)}
                         : optional<U>{};
}

template <class T>
template <class F>
constexpr optional<T&> optional<T&>::or_else(F&& f) const {
    using U = invoke_result_t<F>;
    static_assert(is_same_v<remove_cvref_t<U>, optional>);
    return has_value() ? *value_ : std::forward<F>(f)();
}

// \rSec3[optional.mod]{modifiers}
template <class T>
constexpr void optional<T&>::reset() noexcept {
    value_ = nullptr;
}

/*****************/
/* optional<T&&> */
/*****************/

template <class T>
class optional<T&&> {
  public:
    using value_type = T&&;
    using iterator =
        detail::contiguous_iterator<T,
                                    optional>; // see [optionalrref.iterators]
    using const_iterator =
        detail::contiguous_iterator<const T,
                                    optional>; // see [optionalrref.iterators]

  public:
    // \ref{optionalrref.ctor}, constructors

    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional& rhs) noexcept = default;
    constexpr optional(optional&& rhs) noexcept      = default;
    template <class U = T>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr explicit(!is_convertible_v<U, T>) optional(U&& u) noexcept;
    template <class U>
    constexpr explicit(!is_convertible_v<U, T>)
        optional(const optional<U>& rhs) noexcept;

    // \ref{optionalrref.dtor}, destructor
    constexpr ~optional() = default;

    // \ref{optionalrref.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;

    constexpr optional& operator=(const optional& rhs) noexcept = default;
    constexpr optional& operator=(optional&& rhs) noexcept      = default;

    template <class U = T>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr optional& operator=(U&& u);

    template <class U>
    constexpr optional& operator=(const optional<U>& rhs) noexcept;

    template <class U>
    constexpr optional& operator=(optional<U>&& rhs) = delete;

    template <class U>
        requires(!detail::is_optional<decay_t<U>>)
    constexpr optional& emplace(U&& u) noexcept;

    // \ref{optionalrref.swap}, swap
    constexpr void swap(optional& rhs) noexcept;

    // \ref{optional.iterators}, iterator support
    constexpr iterator       begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator       end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optionalrref.observe}, observers
    constexpr T*       operator->() const noexcept;
    constexpr T&&      operator*() const noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool     has_value() const noexcept;
    constexpr T&&      value() const;
    template <class U>
    constexpr T value_or(U&& u) const;

    // \ref{optionalrref.monadic}, monadic operations
    template <class F>
    constexpr auto and_then(F&& f) const;
    template <class F>
    constexpr auto transform(F&& f) const -> optional<invoke_result_t<F, T&&>>;
    template <class F>
    constexpr optional or_else(F&& f) const;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T* value_; // exposition only
};

//  \rSec3[optionalrref.ctor]{Constructors}
template <class T>
constexpr optional<T&&>::optional() noexcept : value_(nullptr) {}

template <class T>
constexpr optional<T&&>::optional(nullopt_t) noexcept : value_(nullptr) {}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&&>::optional(U&& u) noexcept : value_(addressof(u)) {
    static_assert(is_constructible_v<add_rvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&&");
}

template <class T>
template <class U>
constexpr optional<T&&>::optional(const optional<U>& rhs) noexcept {
    static_assert(is_constructible_v<add_rvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&&");
    if (rhs.has_value())
        value_ = to_address(rhs);
    else
        value_ = nullptr;
}

// \rSec3[optionalrref.assign]{Assignment}
template <class T>
constexpr optional<T&&>& optional<T&&>::operator=(nullopt_t) noexcept {
    value_ = nullptr;
    return *this;
}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&&>& optional<T&&>::operator=(U&& u) {
    static_assert(is_constructible_v<add_rvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&&");
    value_ = addressof(u);
    return *this;
}

template <class T>
template <class U>
constexpr optional<T&&>&
optional<T&&>::operator=(const optional<U>& rhs) noexcept {
    static_assert(is_constructible_v<add_rvalue_reference_t<T>, U>,
                  "Must be able to bind U to T&");
    if (rhs.has_value())
        value_ = to_address(rhs);
    else
        value_ = nullptr;
    return *this;
}

template <class T>
template <class U>
    requires(!detail::is_optional<decay_t<U>>)
constexpr optional<T&&>& optional<T&&>::emplace(U&& u) noexcept {
    return *this = std::forward<U>(u);
}

//   \rSec3[optionalrref.swap]{Swap}

template <class T>
constexpr void optional<T&&>::swap(optional<T&&>& rhs) noexcept {
    std::swap(value_, rhs.value_);
}

// \rSec3[optionalrref.iterators]{Iterator Support}
template <class T>
constexpr optional<T&&>::iterator optional<T&&>::begin() noexcept {
    return iterator(has_value() ? value_ : nullptr);
};

template <class T>
constexpr optional<T&&>::const_iterator optional<T&&>::begin() const noexcept {
    return const_iterator(has_value() ? value_ : nullptr);
};

template <class T>
constexpr optional<T&&>::iterator optional<T&&>::end() noexcept {
    return begin() + has_value();
}

template <class T>
constexpr optional<T&&>::const_iterator optional<T&&>::end() const noexcept {
    return begin() + has_value();
}

// \rSec3[optionalrref.observe]{Observers}
template <class T>
constexpr T* optional<T&&>::operator->() const noexcept {
    return value_;
}

template <class T>
constexpr T&& optional<T&&>::operator*() const noexcept {
    return std::move(*value_);
}

template <class T>
constexpr optional<T&&>::operator bool() const noexcept {
    return value_ != nullptr;
}
template <class T>
constexpr bool optional<T&&>::has_value() const noexcept {
    return value_ != nullptr;
}

template <class T>
constexpr T&& optional<T&&>::value() const {
    if (has_value())
        return std::move(*value_);
    throw bad_optional_access();
}

template <class T>
template <class U>
constexpr T optional<T&&>::value_or(U&& u) const {
    static_assert(is_copy_constructible_v<T>, "T must be copy constructible");
    static_assert(is_convertible_v<decltype(u), T>,
                  "Must be able to bind u to T");
    return has_value() ? std::move(*value_) : std::forward<U>(u);
}

//   \rSec3[optionalrref.monadic]{Monadic operations}
template <class T>
template <class F>
constexpr auto optional<T&&>::and_then(F&& f) const {
    using U = invoke_result_t<F, T&&>;
    static_assert(detail::is_optional<U>, "F must return an optional");
    return (has_value()) ? invoke(std::forward<F>(f), std::move(*value_))
                         : remove_cvref_t<U>();
}

template <class T>
template <class F>
constexpr auto
optional<T&&>::transform(F&& f) const -> optional<invoke_result_t<F, T&&>> {
    using U = invoke_result_t<F, T&&>;
    return (has_value())
               ? optional<U>{invoke(std::forward<F>(f), std::move(*value_))}
               : optional<U>{};
}

template <class T>
template <class F>
constexpr optional<T&&> optional<T&&>::or_else(F&& f) const {
    using U = invoke_result_t<F>;
    static_assert(is_same_v<remove_cvref_t<U>, optional>);
    return has_value() ? std::move(*value_) : std::forward<F>(f)();
}

// \rSec3[optional.mod]{modifiers}
template <class T>
constexpr void optional<T&&>::reset() noexcept {
    value_ = nullptr;
}
} // namespace beman::optional26

#endif // BEMAN_OPTIONAL26_OPTIONAL_HPP

\end{minted}
\end{document}
